{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>A fast, lightweight, and feature-rich Discord bot library written in Rust.</p> <p>Development Notice</p> <p>RustyCord is currently in heavy development and is NOT ready for production use.</p> <ul> <li>APIs may change without notice</li> <li>Features are incomplete and experimental</li> <li>Breaking changes occur frequently</li> <li>Documentation may be outdated</li> <li>Use at your own risk for development/testing only</li> </ul> <p>Do not use this library for production bots yet. Wait for the stable 1.0 release.</p> <p>Current Status</p> <ul> <li>\u2705 Basic bot functionality working</li> <li>\u2705 Message handling system implemented</li> <li>\u2705 Prefix command system functional</li> <li>\u26a0\ufe0f Advanced features under development</li> <li>\u274c Slash commands not yet implemented</li> <li>\u274c Voice support not available</li> <li>\u274c Comprehensive testing needed</li> </ul>"},{"location":"#overview","title":"Overview","text":"<p>rustycord is a modern Discord bot library that provides a clean, type-safe API for building Discord bots. Built with performance and reliability in mind, it offers comprehensive logging, flexible message handling, and an intuitive event system.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83d\ude80 Async/Await Support: Built on Tokio for high-performance async operations</li> <li>\ud83d\udcdd Comprehensive Logging: 5-level logging system with console and file output</li> <li>\ud83d\udd27 Flexible Message Handlers: Trait-based message handling system</li> <li>\ud83c\udfaf Type Safety: Leverages Rust's type system for compile-time safety</li> <li>\ud83d\udce1 WebSocket Gateway: Full Discord Gateway v10 support</li> <li>\ud83c\udf10 HTTP Client: Complete Discord REST API client</li> <li>\ud83c\udfa8 Rich Embeds: Built-in support for Discord embeds</li> <li>\u26a1 Event System: Comprehensive event handling and dispatching</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>use rustycord::{Bot, Client, MessageHandler, logger};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Initialize logging\n    logger::setup_logger(logger::LogLevel::Info)?;\n\n    // Create client and bot\n    let token = std::env::var(\"DISCORD_TOKEN\")?;\n    let client = Client::new(&amp;token).await?;\n    let mut bot = Bot::new(client);\n\n    // Register message handlers\n    bot.register_message_handler(Box::new(EchoHandler));\n\n    // Start the bot\n    bot.start().await?;\n\n    Ok(())\n}\n\nstruct EchoHandler;\n\n#[async_trait::async_trait]\nimpl MessageHandler for EchoHandler {\n    async fn handle_message(&amp;self, message: &amp;rustycord::Message) -&gt; Result&lt;Option&lt;String&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n        if message.content.starts_with(\"!echo \") {\n            let response = message.content.strip_prefix(\"!echo \").unwrap_or(\"\");\n            Ok(Some(response.to_string()))\n        } else {\n            Ok(None)\n        }\n    }\n}\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>Add this to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nrustycord = \"0.1.0\"\ntokio = { version = \"1.0\", features = [\"full\"] }\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Ready to build your first Discord bot? Check out our Getting Started Guide to learn how to set up your development environment and create your first bot.</p>"},{"location":"#examples","title":"Examples","text":"<ul> <li>Basic Bot - Simple echo bot</li> <li>Message Handler - Custom message handling</li> <li>Embeds - Rich embed messages</li> <li>Logging - Comprehensive logging setup</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>User Guide - Learn the fundamentals</li> <li>API Reference - Complete API documentation</li> <li>Examples - Working code examples</li> </ul>"},{"location":"#community","title":"Community","text":"<ul> <li>GitHub Issues - Bug reports and feature requests</li> <li>Discussions - Community support</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"assets/","title":"Brand Assets","text":"<p>This page contains the official rustycord brand assets for use in documentation, presentations, and projects.</p> <p>Usage Guidelines</p> <p>These assets are provided for use in rustycord-related projects and documentation. Please maintain the visual integrity of the brand when using these assets.</p>"},{"location":"assets/#available-assets","title":"Available Assets","text":""},{"location":"assets/#full-logo-1024x1024","title":"Full Logo (1024x1024)","text":"<ul> <li>File: <code>docs/images/rustycord.png</code></li> <li>Dimensions: 1024 \u00d7 1024 pixels</li> <li>Use: Main logo for large displays, presentations, and banners</li> </ul>"},{"location":"assets/#medium-logo-128x128","title":"Medium Logo (128x128)","text":"<ul> <li>File: <code>docs/images/rustycord-logo.png</code></li> <li>Dimensions: 128 \u00d7 128 pixels</li> <li>Use: Documentation headers, medium-sized displays</li> </ul>"},{"location":"assets/#icon-64x64","title":"Icon (64x64)","text":"<ul> <li>File: <code>docs/images/rustycord-icon.png</code></li> <li>Dimensions: 64 \u00d7 64 pixels</li> <li>Use: Navigation bars, small displays, application icons</li> </ul>"},{"location":"assets/#favicon-32x32","title":"Favicon (32x32)","text":"<ul> <li>File: <code>docs/images/rustycord-favicon.png</code></li> <li>Dimensions: 32 \u00d7 32 pixels</li> <li>Use: Browser favicons, very small displays, status indicators</li> </ul>"},{"location":"assets/#usage-examples","title":"Usage Examples","text":""},{"location":"assets/#markdown","title":"Markdown","text":"<pre><code># With centered logo\n&lt;div align=\"center\"&gt;\n  &lt;img src=\"docs/images/rustycord-logo.png\" alt=\"rustycord Logo\" width=\"128\" height=\"128\"&gt;\n\n  # Your Project Title\n&lt;/div&gt;\n\n# Inline with text\n![rustycord](/images/rustycord-favicon.png) rustycord Project\n</code></pre>"},{"location":"assets/#html","title":"HTML","text":"<pre><code>&lt;!-- Centered logo --&gt;\n&lt;div align=\"center\"&gt;\n  &lt;img src=\"/images/rustycord-logo.png\" alt=\"rustycord Logo\" width=\"128\" height=\"128\"&gt;\n  &lt;h1&gt;Your Project Title&lt;/h1&gt;\n&lt;/div&gt;\n\n&lt;!-- Inline logo --&gt;\n&lt;img src=\"/images/rustycord-favicon.png\" alt=\"rustycord\" width=\"32\" height=\"32\"&gt; rustycord Project\n</code></pre>"},{"location":"assets/#mkdocs-configuration","title":"MkDocs Configuration","text":"<pre><code>theme:\n  name: material\n  logo: images/rustycord-logo.png\n  favicon: images/rustycord-favicon.png\n</code></pre> <p>Responsive Design</p> <p>Use different sized assets based on the display context:</p> <ul> <li>Desktop headers: Use 128px logo</li> <li>Mobile/responsive: Use 64px icon</li> <li>Browser tabs: Use 32px favicon</li> <li>Large banners: Use full 1024px version</li> </ul>"},{"location":"assets/#file-formats","title":"File Formats","text":"<p>All assets are provided in PNG format with transparent backgrounds for maximum compatibility and flexibility.</p> rustycord - A Discord bot library for Rust"},{"location":"development-status/","title":"Development Status","text":""},{"location":"development-status/#development-status","title":"\u26a0\ufe0f Development Status","text":"<p>Not Production Ready</p> <p>rustycord is currently in heavy development and should NOT be used for production bots.</p> <p>This library is experimental, unstable, and subject to frequent breaking changes. Use only for learning, experimentation, and development purposes.</p>"},{"location":"development-status/#current-development-phase","title":"Current Development Phase","text":"<p>rustycord is in Alpha development with the following characteristics:</p> <ul> <li>\ud83d\udea8 Breaking changes occur frequently</li> <li>\ud83d\udea8 APIs are unstable and will change</li> <li>\ud83d\udea8 Features are incomplete or missing</li> <li>\ud83d\udea8 Limited testing and validation</li> <li>\ud83d\udea8 No backward compatibility guarantees</li> </ul>"},{"location":"development-status/#feature-status","title":"Feature Status","text":"Component Status Notes Basic Bot Framework \u2705 Working Core functionality implemented HTTP Client \u2705 Working Basic REST API calls functional Gateway Connection \u2705 Working WebSocket connection stable Message Handling \u2705 Working Message events and handlers functional Prefix Commands \u2705 Working Command system implemented Logging System \u2705 Working Comprehensive logging available Event System \u26a0\ufe0f Partial Basic events work, advanced features missing Embed Support \u26a0\ufe0f Partial Basic embeds work, complex features missing Slash Commands \u274c Missing Not implemented yet Voice Support \u274c Missing Not planned for initial release Sharding \u274c Missing Basic structure exists, not functional Rate Limiting \u274c Missing No rate limit handling Comprehensive Testing \u274c Missing Minimal test coverage Documentation \u26a0\ufe0f Partial Basic docs exist, many gaps Stable API \u274c Missing APIs change frequently"},{"location":"development-status/#what-works-now","title":"What Works Now","text":"<p>You can use rustycord for:</p> <ul> <li>\u2705 Learning Discord bot development</li> <li>\u2705 Experimenting with Rust async programming</li> <li>\u2705 Building simple test bots</li> <li>\u2705 Contributing to development</li> <li>\u2705 Prototyping bot ideas</li> </ul>"},{"location":"development-status/#what-doesnt-work","title":"What Doesn't Work","text":"<p>Do not expect:</p> <ul> <li>\u274c Production-ready stability</li> <li>\u274c Complete Discord API coverage</li> <li>\u274c Backward compatibility</li> <li>\u274c Professional support</li> <li>\u274c Performance optimization</li> <li>\u274c Advanced Discord features</li> </ul>"},{"location":"development-status/#development-roadmap","title":"Development Roadmap","text":""},{"location":"development-status/#phase-1-core-stability-current","title":"Phase 1: Core Stability (Current)","text":"<ul> <li>Fix remaining message handling issues</li> <li>Improve error handling</li> <li>Add basic testing</li> <li>Stabilize core APIs</li> </ul>"},{"location":"development-status/#phase-2-essential-features","title":"Phase 2: Essential Features","text":"<ul> <li>Implement slash commands</li> <li>Add rate limiting</li> <li>Improve sharding support</li> <li>Enhanced embed system</li> </ul>"},{"location":"development-status/#phase-3-advanced-features","title":"Phase 3: Advanced Features","text":"<ul> <li>Voice support consideration</li> <li>Performance optimization</li> <li>Comprehensive testing</li> <li>API documentation</li> </ul>"},{"location":"development-status/#phase-4-stability-release","title":"Phase 4: Stability &amp; Release","text":"<ul> <li>API freeze for 1.0</li> <li>Comprehensive testing</li> <li>Production readiness</li> <li>Stable release</li> </ul>"},{"location":"development-status/#risk-assessment","title":"Risk Assessment","text":"Risk Level Description \ud83d\udd34 HIGH Your bot may break with library updates \ud83d\udd34 HIGH Data loss or corruption possible \ud83d\udd34 HIGH Security vulnerabilities may exist \ud83d\udfe1 MEDIUM Performance issues expected \ud83d\udfe1 MEDIUM Limited feature set \ud83d\udfe2 LOW Good for learning and experimentation"},{"location":"development-status/#alternatives-for-production","title":"Alternatives for Production","text":"<p>If you need a production-ready Discord bot library for Rust, consider:</p> <ul> <li>Serenity - Mature, stable, production-ready</li> <li>Twilight - Modern, modular, well-maintained</li> <li>Poise - Command framework built on Serenity</li> </ul>"},{"location":"development-status/#contributing","title":"Contributing","text":"<p>Despite being in development, contributions are welcome:</p> <ul> <li>\ud83d\udc1b Bug reports - Help identify issues</li> <li>\ud83d\udca1 Feature requests - Suggest improvements</li> <li>\ud83d\udd27 Code contributions - Submit pull requests</li> <li>\ud83d\udcda Documentation - Improve guides and examples</li> <li>\ud83e\uddea Testing - Help test new features</li> </ul> <p>See the GitHub repository for contribution guidelines.</p>"},{"location":"development-status/#getting-updates","title":"Getting Updates","text":"<p>Stay informed about rustycord development:</p> <ul> <li>\u2b50 Star the repository for notifications</li> <li>\ud83d\udc40 Watch releases for version updates</li> <li>\ud83d\udccb Check issues for known problems</li> <li>\ud83d\udcac Join discussions for community updates</li> </ul>"},{"location":"development-status/#legal-notice","title":"Legal Notice","text":"<p>By using rustycord, you acknowledge:</p> <ul> <li>This software is provided \"as is\" without warranty</li> <li>The developers are not responsible for any issues or damages</li> <li>Use in production environments is strongly discouraged</li> <li>Breaking changes may occur at any time</li> </ul> <p>Remember: Wait for the stable 1.0 release before considering production use.</p>"},{"location":"troubleshooting/","title":"Troubleshooting rustycord","text":"<p>Common issues and solutions when using rustycord.</p>"},{"location":"troubleshooting/#bot-not-responding-to-commands","title":"Bot Not Responding to Commands","text":""},{"location":"troubleshooting/#symptoms","title":"Symptoms","text":"<ul> <li>Bot connects successfully</li> <li>Bot appears online in Discord</li> <li>Commands like <code>!ping</code> or <code>!help</code> don't trigger any response</li> <li>No message events in logs</li> </ul>"},{"location":"troubleshooting/#solution-enable-message-content-intent","title":"Solution: Enable Message Content Intent","text":"<p>This is the most common issue. Discord requires explicit permission to read message content.</p> <ol> <li>Go to Discord Developer Portal:</li> <li>Visit https://discord.com/developers/applications</li> <li> <p>Select your application</p> </li> <li> <p>Navigate to Bot section:</p> </li> <li> <p>Click \"Bot\" in the left sidebar</p> </li> <li> <p>Enable Message Content Intent:</p> </li> <li>Scroll down to \"Privileged Gateway Intents\"</li> <li>Toggle ON \"Message Content Intent\"</li> <li> <p>Save changes</p> </li> <li> <p>Update your code to use proper intents:    <pre><code>use rustycord::gateway::intents;\n\n// Include message-related intents\nlet intents = intents::GUILDS | intents::GUILD_MESSAGES | intents::MESSAGE_CONTENT;\nlet mut bot = BotBase::new(Some(intents)).await;\n</code></pre></p> </li> </ol>"},{"location":"troubleshooting/#verify-in-logs","title":"Verify in Logs","text":"<p>Look for these log messages when your bot starts: <pre><code>\u2705 Message handler registered: YourHandler (Total: 1)\n\ud83d\ude80 Bot is ready!\n\ud83c\udff0 Joined guild: YourServerName\n</code></pre></p>"},{"location":"troubleshooting/#authentication-issues","title":"Authentication Issues","text":""},{"location":"troubleshooting/#invalid-token-error","title":"Invalid Token Error","text":"<pre><code>Error: HTTP error: 401 Unauthorized\n</code></pre> <p>Solutions: 1. Check your <code>.env</code> file:    <pre><code>DISCORD_TOKEN=your_actual_bot_token_here\n</code></pre> 2. No extra spaces or quotes around the token 3. Regenerate token if necessary in Discord Developer Portal</p>"},{"location":"troubleshooting/#token-not-found-error","title":"Token Not Found Error","text":"<pre><code>DISCORD_TOKEN environment variable not set\n</code></pre> <p>Solutions: 1. Create <code>.env</code> file in your project root 2. Copy from example: <code>cp .env.example .env</code> 3. Add dotenv dependency in <code>Cargo.toml</code>:    <pre><code>[dependencies]\ndotenv = \"0.15\"\n</code></pre> 4. Call dotenv in code:    <pre><code>dotenv::dotenv().ok();\n</code></pre></p>"},{"location":"troubleshooting/#permission-issues","title":"Permission Issues","text":""},{"location":"troubleshooting/#missing-access-error","title":"Missing Access Error","text":"<pre><code>Error: Missing Access\n</code></pre> <p>Solutions: 1. Re-invite your bot with proper permissions 2. Check bot role position (should be above roles it needs to manage) 3. Grant essential permissions:    - Send Messages    - Read Message History    - Read Messages</p>"},{"location":"troubleshooting/#generate-proper-invite-url","title":"Generate proper invite URL:","text":"<ol> <li>Discord Developer Portal \u2192 Your App \u2192 OAuth2 \u2192 URL Generator</li> <li>Select Scopes: <code>bot</code></li> <li>Select Permissions:</li> <li>Send Messages</li> <li>Read Message History</li> <li>Use Slash Commands (if needed)</li> <li>Use generated URL to invite bot</li> </ol>"},{"location":"troubleshooting/#connection-issues","title":"Connection Issues","text":""},{"location":"troubleshooting/#websocket-connection-failed","title":"WebSocket Connection Failed","text":"<pre><code>Error: Connection timeout\nError: WebSocket connection failed\n</code></pre> <p>Solutions: 1. Check internet connection 2. Verify Discord status: https://discordstatus.com 3. Check firewall settings 4. Try different network (mobile hotspot to test)</p>"},{"location":"troubleshooting/#gateway-connection-issues","title":"Gateway Connection Issues","text":"<pre><code>Failed to connect to Discord gateway\n</code></pre> <p>Solutions: 1. Check bot token validity 2. Verify intents configuration 3. Check rate limits (too many connection attempts)</p>"},{"location":"troubleshooting/#message-handler-issues","title":"Message Handler Issues","text":""},{"location":"troubleshooting/#handler-not-triggered","title":"Handler Not Triggered","text":"<pre><code>Handler registered but not executing\n</code></pre> <p>Check these: 1. Message Content Intent enabled 2. Bot not responding to its own messages:    <pre><code>if message.author.bot.unwrap_or(false) {\n    return Ok(());\n}\n</code></pre> 3. Correct message format (right prefix, etc.)</p>"},{"location":"troubleshooting/#multiple-responses","title":"Multiple Responses","text":"<pre><code>Bot responding multiple times to same command\n</code></pre> <p>Solutions: 1. Remove duplicate handlers 2. Check for multiple bot instances 3. Ensure handlers return early when appropriate</p>"},{"location":"troubleshooting/#logging-and-debugging","title":"Logging and Debugging","text":""},{"location":"troubleshooting/#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code>// In your main function\nlogger::setup_logger(\"debug\".to_string())?;\n\n// Or via environment variable\nRUST_LOG=debug cargo run\n</code></pre>"},{"location":"troubleshooting/#check-log-files","title":"Check Log Files","text":"<p>Most examples create <code>output.log</code>: <pre><code>tail -f output.log\ngrep -i \"error\" output.log\ngrep -i \"message\" output.log\n</code></pre></p>"},{"location":"troubleshooting/#common-log-messages","title":"Common Log Messages","text":"<p>Success indicators: <pre><code>\u2705 Successfully authenticated as: YourBot\n\ud83d\udd0c Connected to The Discord\n\ud83d\ude80 Bot is ready!\n\ud83c\udff0 Joined guild: YourServer\n</code></pre></p> <p>Problem indicators: <pre><code>\u274c Authentication failed\n\u274c Failed to connect to Discord gateway\nError: 401 Unauthorized\nError: Missing Access\n</code></pre></p>"},{"location":"troubleshooting/#performance-issues","title":"Performance Issues","text":""},{"location":"troubleshooting/#high-cpu-usage","title":"High CPU Usage","text":"<pre><code>Bot using too much CPU\n</code></pre> <p>Solutions: 1. Check for infinite loops in message handlers 2. Avoid blocking operations in async handlers 3. Use appropriate log levels (avoid \"trace\" in production)</p>"},{"location":"troubleshooting/#memory-leaks","title":"Memory Leaks","text":"<pre><code>Memory usage keeps growing\n</code></pre> <p>Solutions: 1. Check for unbounded collections in handlers 2. Properly drop resources in async code 3. Use weak references where appropriate</p>"},{"location":"troubleshooting/#development-tips","title":"Development Tips","text":""},{"location":"troubleshooting/#quick-testing","title":"Quick Testing","text":"<ol> <li>Create a test server for development</li> <li>Use debug logging during development</li> <li>Test with simple commands first (<code>!ping</code>)</li> </ol>"},{"location":"troubleshooting/#code-organization","title":"Code Organization","text":"<pre><code>// Separate concerns\nstruct MyBot {\n    client: Client,\n    commands: PrefixListener,\n}\n\nimpl MyBot {\n    async fn setup(&amp;mut self) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n        // Setup logic here\n    }\n}\n</code></pre>"},{"location":"troubleshooting/#error-handling","title":"Error Handling","text":"<pre><code>// Always handle errors gracefully\nmatch some_operation().await {\n    Ok(result) =&gt; {\n        log::info!(\"Operation successful: {:?}\", result);\n    }\n    Err(e) =&gt; {\n        log::error!(\"Operation failed: {}\", e);\n        // Don't panic, return gracefully\n        return Err(e);\n    }\n}\n</code></pre>"},{"location":"troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you're still having issues:</p> <ol> <li>Check the examples in the repository</li> <li>Review the documentation </li> <li>Search existing issues on GitHub</li> <li>Create a minimal reproduction case</li> <li>Include logs and error messages when asking for help</li> </ol>"},{"location":"troubleshooting/#useful-information-to-include","title":"Useful Information to Include","text":"<p>When reporting issues: - Rust version: <code>rustc --version</code> - Operating system - Complete error messages - Minimal code that reproduces the issue - Bot permissions and intents configuration</p>"},{"location":"api/client/","title":"Client API Reference","text":"<p>Complete reference for the rustycord Client API.</p>"},{"location":"api/client/#overview","title":"Overview","text":"<p>The <code>Client</code> struct is the core HTTP client for interacting with the Discord REST API. It handles authentication, rate limiting, and provides methods for all Discord API endpoints.</p>"},{"location":"api/client/#client-structure","title":"Client Structure","text":"<pre><code>use rustycord::client::Client;\nuse rustycord::models::{User, Message, Guild, Channel};\n\npub struct Client {\n    token: String,\n    base_url: String,\n    user_agent: String,\n    http_client: reqwest::Client,\n}\n</code></pre>"},{"location":"api/client/#creating-a-client","title":"Creating a Client","text":""},{"location":"api/client/#basic-client","title":"Basic Client","text":"<pre><code>use rustycord::Client;\n\nlet client = Client::new();\n</code></pre>"},{"location":"api/client/#client-with-custom-configuration","title":"Client with Custom Configuration","text":"<pre><code>use rustycord::Client;\n\nlet client = Client::builder()\n    .user_agent(\"MyBot/1.0\")\n    .timeout(std::time::Duration::from_secs(30))\n    .build();\n</code></pre>"},{"location":"api/client/#authentication","title":"Authentication","text":""},{"location":"api/client/#login","title":"Login","text":"<pre><code>use rustycord::models::UserResponse;\n\nlet mut client = Client::new();\nlet user_response: UserResponse = client.login(token).await?;\n\nprintln!(\"Logged in as: {}\", user_response.username);\nprintln!(\"Bot ID: {}\", user_response.id);\n</code></pre>"},{"location":"api/client/#get-current-user","title":"Get Current User","text":"<pre><code>let current_user = client.get_current_user().await?;\nprintln!(\"Current user: {:#?}\", current_user);\n</code></pre>"},{"location":"api/client/#message-operations","title":"Message Operations","text":""},{"location":"api/client/#send-message","title":"Send Message","text":"<pre><code>use rustycord::models::CreateMessage;\n\n// Simple text message\nlet message = client.send_message(\"channel_id\", \"Hello, world!\").await?;\n\n// Message with embed\nlet embed = rustycord::embeds::Embed::new()\n    .title(\"Test Embed\")\n    .description(\"This is a test embed\")\n    .color(0x00ff00);\n\nlet create_message = CreateMessage::new()\n    .content(\"Message with embed\")\n    .embed(embed);\n\nlet message = client.send_message_with_options(\"channel_id\", create_message).await?;\n</code></pre>"},{"location":"api/client/#edit-message","title":"Edit Message","text":"<pre><code>let edited_message = client.edit_message(\n    \"channel_id\",\n    \"message_id\", \n    \"Updated message content\"\n).await?;\n</code></pre>"},{"location":"api/client/#delete-message","title":"Delete Message","text":"<pre><code>client.delete_message(\"channel_id\", \"message_id\").await?;\n</code></pre>"},{"location":"api/client/#get-message","title":"Get Message","text":"<pre><code>let message = client.get_message(\"channel_id\", \"message_id\").await?;\nprintln!(\"Message: {}\", message.content);\n</code></pre>"},{"location":"api/client/#get-channel-messages","title":"Get Channel Messages","text":"<pre><code>use rustycord::models::GetMessagesOptions;\n\n// Get last 10 messages\nlet messages = client.get_channel_messages(\"channel_id\", None).await?;\n\n// Get messages with options\nlet options = GetMessagesOptions::new()\n    .limit(50)\n    .before(\"message_id\");\n\nlet messages = client.get_channel_messages(\"channel_id\", Some(options)).await?;\n</code></pre>"},{"location":"api/client/#channel-operations","title":"Channel Operations","text":""},{"location":"api/client/#get-channel","title":"Get Channel","text":"<pre><code>let channel = client.get_channel(\"channel_id\").await?;\nprintln!(\"Channel name: {}\", channel.name.unwrap_or(\"Unknown\".to_string()));\n</code></pre>"},{"location":"api/client/#create-channel","title":"Create Channel","text":"<pre><code>use rustycord::models::{CreateChannel, ChannelType};\n\nlet create_channel = CreateChannel::new()\n    .name(\"new-channel\")\n    .channel_type(ChannelType::GuildText)\n    .topic(\"Channel topic\");\n\nlet channel = client.create_guild_channel(\"guild_id\", create_channel).await?;\n</code></pre>"},{"location":"api/client/#modify-channel","title":"Modify Channel","text":"<pre><code>use rustycord::models::ModifyChannel;\n\nlet modify_channel = ModifyChannel::new()\n    .name(\"updated-channel-name\")\n    .topic(\"Updated topic\");\n\nlet channel = client.modify_channel(\"channel_id\", modify_channel).await?;\n</code></pre>"},{"location":"api/client/#delete-channel","title":"Delete Channel","text":"<pre><code>client.delete_channel(\"channel_id\").await?;\n</code></pre>"},{"location":"api/client/#guild-operations","title":"Guild Operations","text":""},{"location":"api/client/#get-guild","title":"Get Guild","text":"<pre><code>let guild = client.get_guild(\"guild_id\").await?;\nprintln!(\"Guild name: {}\", guild.name);\nprintln!(\"Member count: {}\", guild.member_count.unwrap_or(0));\n</code></pre>"},{"location":"api/client/#get-guild-channels","title":"Get Guild Channels","text":"<pre><code>let channels = client.get_guild_channels(\"guild_id\").await?;\nfor channel in channels {\n    println!(\"Channel: {}\", channel.name.unwrap_or(\"Unknown\".to_string()));\n}\n</code></pre>"},{"location":"api/client/#get-guild-members","title":"Get Guild Members","text":"<pre><code>use rustycord::models::GetGuildMembersOptions;\n\n// Get all members (paginated)\nlet members = client.get_guild_members(\"guild_id\", None).await?;\n\n// Get members with options\nlet options = GetGuildMembersOptions::new()\n    .limit(100)\n    .after(\"user_id\");\n\nlet members = client.get_guild_members(\"guild_id\", Some(options)).await?;\n</code></pre>"},{"location":"api/client/#get-guild-member","title":"Get Guild Member","text":"<pre><code>let member = client.get_guild_member(\"guild_id\", \"user_id\").await?;\nprintln!(\"Member: {}\", member.user.username);\n</code></pre>"},{"location":"api/client/#user-operations","title":"User Operations","text":""},{"location":"api/client/#get-user","title":"Get User","text":"<pre><code>let user = client.get_user(\"user_id\").await?;\nprintln!(\"Username: {}\", user.username);\nprintln!(\"Discriminator: {}\", user.discriminator);\n</code></pre>"},{"location":"api/client/#create-dm-channel","title":"Create DM Channel","text":"<pre><code>let dm_channel = client.create_dm(\"user_id\").await?;\nprintln!(\"DM Channel ID: {}\", dm_channel.id);\n</code></pre>"},{"location":"api/client/#role-operations","title":"Role Operations","text":""},{"location":"api/client/#get-guild-roles","title":"Get Guild Roles","text":"<pre><code>let roles = client.get_guild_roles(\"guild_id\").await?;\nfor role in roles {\n    println!(\"Role: {} ({})\", role.name, role.id);\n}\n</code></pre>"},{"location":"api/client/#create-role","title":"Create Role","text":"<pre><code>use rustycord::models::CreateRole;\n\nlet create_role = CreateRole::new()\n    .name(\"New Role\")\n    .color(0xff0000)\n    .hoist(true)\n    .mentionable(true);\n\nlet role = client.create_guild_role(\"guild_id\", create_role).await?;\n</code></pre>"},{"location":"api/client/#modify-role","title":"Modify Role","text":"<pre><code>use rustycord::models::ModifyRole;\n\nlet modify_role = ModifyRole::new()\n    .name(\"Updated Role\")\n    .color(0x00ff00);\n\nlet role = client.modify_guild_role(\"guild_id\", \"role_id\", modify_role).await?;\n</code></pre>"},{"location":"api/client/#delete-role","title":"Delete Role","text":"<pre><code>client.delete_guild_role(\"guild_id\", \"role_id\").await?;\n</code></pre>"},{"location":"api/client/#add-role-to-member","title":"Add Role to Member","text":"<pre><code>client.add_guild_member_role(\"guild_id\", \"user_id\", \"role_id\").await?;\n</code></pre>"},{"location":"api/client/#remove-role-from-member","title":"Remove Role from Member","text":"<pre><code>client.remove_guild_member_role(\"guild_id\", \"user_id\", \"role_id\").await?;\n</code></pre>"},{"location":"api/client/#reaction-operations","title":"Reaction Operations","text":""},{"location":"api/client/#add-reaction","title":"Add Reaction","text":"<pre><code>// Unicode emoji\nclient.create_reaction(\"channel_id\", \"message_id\", \"\ud83d\udc4d\").await?;\n\n// Custom emoji\nclient.create_reaction(\"channel_id\", \"message_id\", \"custom_emoji:123456789\").await?;\n</code></pre>"},{"location":"api/client/#remove-reaction","title":"Remove Reaction","text":"<pre><code>// Remove own reaction\nclient.delete_own_reaction(\"channel_id\", \"message_id\", \"\ud83d\udc4d\").await?;\n\n// Remove user's reaction\nclient.delete_user_reaction(\"channel_id\", \"message_id\", \"\ud83d\udc4d\", \"user_id\").await?;\n\n// Remove all reactions\nclient.delete_all_reactions(\"channel_id\", \"message_id\").await?;\n</code></pre>"},{"location":"api/client/#get-reactions","title":"Get Reactions","text":"<pre><code>let users = client.get_reactions(\"channel_id\", \"message_id\", \"\ud83d\udc4d\").await?;\nfor user in users {\n    println!(\"User who reacted: {}\", user.username);\n}\n</code></pre>"},{"location":"api/client/#error-handling","title":"Error Handling","text":""},{"location":"api/client/#client-errors","title":"Client Errors","text":"<pre><code>use rustycord::client::{ClientError, ClientResult};\n\nmatch client.send_message(\"channel_id\", \"Hello\").await {\n    Ok(message) =&gt; println!(\"Message sent: {}\", message.id),\n    Err(ClientError::Http(status, body)) =&gt; {\n        eprintln!(\"HTTP Error {}: {}\", status, body);\n    },\n    Err(ClientError::RateLimit(retry_after)) =&gt; {\n        eprintln!(\"Rate limited. Retry after: {}s\", retry_after);\n    },\n    Err(ClientError::Network(e)) =&gt; {\n        eprintln!(\"Network error: {}\", e);\n    },\n    Err(ClientError::Json(e)) =&gt; {\n        eprintln!(\"JSON parsing error: {}\", e);\n    },\n}\n</code></pre>"},{"location":"api/client/#rate-limiting","title":"Rate Limiting","text":"<pre><code>use rustycord::client::RateLimitInfo;\n\n// The client automatically handles rate limits, but you can check status\nlet rate_limit_info = client.get_rate_limit_info(\"endpoint\").await?;\nprintln!(\"Remaining requests: {}\", rate_limit_info.remaining);\nprintln!(\"Reset time: {}\", rate_limit_info.reset_after);\n</code></pre>"},{"location":"api/client/#advanced-usage","title":"Advanced Usage","text":""},{"location":"api/client/#custom-http-headers","title":"Custom HTTP Headers","text":"<pre><code>use rustycord::client::ClientBuilder;\n\nlet client = ClientBuilder::new()\n    .header(\"X-Custom-Header\", \"value\")\n    .build();\n</code></pre>"},{"location":"api/client/#proxy-support","title":"Proxy Support","text":"<pre><code>let client = ClientBuilder::new()\n    .proxy(\"http://proxy.example.com:8080\")\n    .build();\n</code></pre>"},{"location":"api/client/#timeout-configuration","title":"Timeout Configuration","text":"<pre><code>let client = ClientBuilder::new()\n    .timeout(std::time::Duration::from_secs(60))\n    .connect_timeout(std::time::Duration::from_secs(10))\n    .build();\n</code></pre>"},{"location":"api/client/#async-patterns","title":"Async Patterns","text":""},{"location":"api/client/#concurrent-requests","title":"Concurrent Requests","text":"<pre><code>use futures::future::join_all;\n\nlet message_futures = vec![\n    client.send_message(\"channel1\", \"Hello 1\"),\n    client.send_message(\"channel2\", \"Hello 2\"),\n    client.send_message(\"channel3\", \"Hello 3\"),\n];\n\nlet results = join_all(message_futures).await;\nfor result in results {\n    match result {\n        Ok(message) =&gt; println!(\"Sent message: {}\", message.id),\n        Err(e) =&gt; eprintln!(\"Failed to send message: {}\", e),\n    }\n}\n</code></pre>"},{"location":"api/client/#stream-processing","title":"Stream Processing","text":"<pre><code>use futures::stream::{self, StreamExt};\n\nlet channel_ids = vec![\"channel1\", \"channel2\", \"channel3\"];\nlet client = std::sync::Arc::new(client);\n\nlet results: Vec&lt;_&gt; = stream::iter(channel_ids)\n    .map(|channel_id| {\n        let client = client.clone();\n        async move {\n            client.get_channel_messages(channel_id, None).await\n        }\n    })\n    .buffer_unordered(3) // Process up to 3 requests concurrently\n    .collect()\n    .await;\n</code></pre>"},{"location":"api/client/#testing","title":"Testing","text":""},{"location":"api/client/#mock-client","title":"Mock Client","text":"<pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n    use rustycord::client::MockClient;\n\n    #[tokio::test]\n    async fn test_send_message() {\n        let mut mock_client = MockClient::new();\n\n        mock_client\n            .expect_send_message()\n            .with(\"channel_id\", \"Hello\")\n            .returning(|_, _| Ok(Message::default()));\n\n        let result = mock_client.send_message(\"channel_id\", \"Hello\").await;\n        assert!(result.is_ok());\n    }\n}\n</code></pre>"},{"location":"api/client/#examples","title":"Examples","text":""},{"location":"api/client/#bot-initialization-with-client","title":"Bot Initialization with Client","text":"<pre><code>use rustycord::{Client, Bot};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let token = std::env::var(\"DISCORD_TOKEN\")?;\n\n    // Create and configure client\n    let mut client = Client::new();\n    let user_response = client.login(token).await?;\n\n    println!(\"Bot logged in as: {}\", user_response.username);\n\n    // Use client directly or with Bot\n    let mut bot = Bot::with_client(client);\n    bot.start().await?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"api/client/#message-processing-pipeline","title":"Message Processing Pipeline","text":"<pre><code>async fn process_messages(client: &amp;Client, channel_id: &amp;str) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Get recent messages\n    let messages = client.get_channel_messages(channel_id, None).await?;\n\n    // Process each message\n    for message in messages {\n        if message.content.contains(\"spam\") {\n            // Delete spam message\n            client.delete_message(channel_id, &amp;message.id).await?;\n\n            // Send warning to user\n            let dm_channel = client.create_dm(&amp;message.author.id).await?;\n            client.send_message(&amp;dm_channel.id, \"Please don't spam!\").await?;\n        }\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"api/client/#api-reference-summary","title":"API Reference Summary","text":"Method Description Returns <code>Client::new()</code> Create new client <code>Client</code> <code>client.login(token)</code> Authenticate with Discord <code>UserResponse</code> <code>client.send_message(channel, content)</code> Send text message <code>Message</code> <code>client.get_channel(id)</code> Get channel info <code>Channel</code> <code>client.get_guild(id)</code> Get guild info <code>Guild</code> <code>client.get_user(id)</code> Get user info <code>User</code> <code>client.create_reaction(channel, message, emoji)</code> Add reaction <code>()</code> <code>client.get_guild_members(guild, options)</code> Get guild members <code>Vec&lt;Member&gt;</code>"},{"location":"api/client/#rate-limits","title":"Rate Limits","text":"<p>The Discord API has rate limits that the client automatically handles:</p> <ul> <li>Global Rate Limit: 50 requests per second</li> <li>Per-Route Rate Limits: Vary by endpoint</li> <li>Per-Guild Rate Limits: Apply to guild-specific operations</li> </ul> <p>The client will automatically retry requests that hit rate limits with appropriate backoff.</p>"},{"location":"api/client/#related-documentation","title":"Related Documentation","text":"<ul> <li>Bot Basics - Using the client with bots</li> <li>Message Handler Example - Client usage in handlers</li> <li>Error Handling Guide - Handling client errors</li> </ul>"},{"location":"examples/basic-bot/","title":"Basic Bot Example","text":"<p>This example demonstrates how to create a simple Discord bot using rustycord.</p>"},{"location":"examples/basic-bot/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust 1.70 or later</li> <li>A Discord application and bot token</li> </ul>"},{"location":"examples/basic-bot/#code","title":"Code","text":"<pre><code>use rustycord::{Bot, Client, MessageHandler, logger};\nuse rustycord::models::Message;\nuse async_trait::async_trait;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Initialize logging with info level\n    logger::setup_logger(\"info\".to_string())?;\n\n    // Get bot token from environment variable\n    let token = std::env::var(\"DISCORD_TOKEN\")\n        .expect(\"Expected DISCORD_TOKEN environment variable\");\n\n    // Create a new bot instance\n    let mut bot = Bot::new(None).await;\n\n    // Login the bot\n    let user_response = bot.login(token).await;\n    println!(\"Bot logged in as: {:?}\", user_response.username);\n\n    // Register message handlers\n    bot.register_message_handler(Box::new(PingHandler));\n    bot.register_message_handler(Box::new(EchoHandler));\n\n    // Start the bot (this will block until the bot is stopped)\n    bot.start().await?;\n\n    Ok(())\n}\n\n/// A simple ping-pong handler\nstruct PingHandler;\n\n#[async_trait]\nimpl MessageHandler for PingHandler {\n    async fn handle_message(&amp;self, message: &amp;Message) -&gt; Result&lt;Option&lt;String&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n        if message.content == \"!ping\" {\n            Ok(Some(\"Pong! \ud83c\udfd3\".to_string()))\n        } else {\n            Ok(None)\n        }\n    }\n}\n\n/// An echo handler that repeats user input\nstruct EchoHandler;\n\n#[async_trait]\nimpl MessageHandler for EchoHandler {\n    async fn handle_message(&amp;self, message: &amp;Message) -&gt; Result&lt;Option&lt;String&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n        if message.content.starts_with(\"!echo \") {\n            let response = message.content.strip_prefix(\"!echo \").unwrap_or(\"\");\n            Ok(Some(format!(\"\ud83d\udd0a {}\", response)))\n        } else {\n            Ok(None)\n        }\n    }\n}\n</code></pre>"},{"location":"examples/basic-bot/#environment-setup","title":"Environment Setup","text":"<p>Create a <code>.env</code> file in your project root:</p> <pre><code>DISCORD_TOKEN=your_bot_token_here\n</code></pre>"},{"location":"examples/basic-bot/#running-the-bot","title":"Running the Bot","text":"<ol> <li> <p>Set up your environment variable:    <pre><code>export DISCORD_TOKEN=\"your_bot_token_here\"\n</code></pre></p> </li> <li> <p>Run the bot:    <pre><code>cargo run\n</code></pre></p> </li> </ol>"},{"location":"examples/basic-bot/#features-demonstrated","title":"Features Demonstrated","text":"<ul> <li>Bot Initialization: Creating and configuring a bot instance</li> <li>Login: Authenticating with Discord</li> <li>Message Handlers: Responding to specific commands</li> <li>Logging: Setting up structured logging</li> <li>Async Operations: Using Rust's async/await for non-blocking operations</li> </ul>"},{"location":"examples/basic-bot/#commands","title":"Commands","text":"<p>Once the bot is running, you can test these commands in your Discord server:</p> <ul> <li><code>!ping</code> - Bot responds with \"Pong! \ud83c\udfd3\"</li> <li><code>!echo &lt;message&gt;</code> - Bot echoes your message with a speaker emoji</li> </ul>"},{"location":"examples/basic-bot/#next-steps","title":"Next Steps","text":"<ul> <li>Message Handler Guide - Learn more about message handling</li> <li>Embeds Example - Add rich embed responses</li> <li>Logging Example - Advanced logging configuration</li> </ul>"},{"location":"examples/embeds/","title":"Embeds Example","text":"<p>Learn how to create rich, interactive embeds for your Discord bot using rustycord.</p>"},{"location":"examples/embeds/#overview","title":"Overview","text":"<p>Discord embeds are rich message components that can display formatted text, images, fields, and other interactive elements. rustycord provides a comprehensive embed system for creating beautiful bot responses.</p>"},{"location":"examples/embeds/#basic-embed","title":"Basic Embed","text":"<pre><code>use rustycord::{Bot, MessageHandler, embeds::Embed, embeds::EmbedField};\nuse rustycord::models::Message;\nuse async_trait::async_trait;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let token = std::env::var(\"DISCORD_TOKEN\")?;\n    let mut bot = Bot::new(None).await;\n\n    bot.login(token).await;\n    bot.register_message_handler(Box::new(EmbedHandler));\n\n    bot.start().await?;\n    Ok(())\n}\n\nstruct EmbedHandler;\n\n#[async_trait]\nimpl MessageHandler for EmbedHandler {\n    async fn handle_message(&amp;self, message: &amp;Message) -&gt; Result&lt;Option&lt;String&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n        match message.content.as_str() {\n            \"!embed basic\" =&gt; {\n                let embed = Embed::new()\n                    .title(\"Hello, World!\")\n                    .description(\"This is a basic embed example.\")\n                    .color(0x00ff00); // Green color\n\n                // Send embed (simplified - actual implementation may vary)\n                Ok(Some(format!(\"Embed: {}\", embed.to_json())))\n            },\n            _ =&gt; Ok(None)\n        }\n    }\n}\n</code></pre>"},{"location":"examples/embeds/#rich-embed-examples","title":"Rich Embed Examples","text":""},{"location":"examples/embeds/#info-embed","title":"Info Embed","text":"<pre><code>fn create_info_embed() -&gt; Embed {\n    Embed::new()\n        .title(\"\ud83d\udcca Server Statistics\")\n        .description(\"Current server information and statistics\")\n        .color(0x3498db) // Blue\n        .thumbnail(\"https://example.com/server-icon.png\")\n        .add_field(EmbedField::new(\"Total Members\", \"1,234\", true))\n        .add_field(EmbedField::new(\"Online Members\", \"567\", true))\n        .add_field(EmbedField::new(\"Text Channels\", \"15\", true))\n        .add_field(EmbedField::new(\"Voice Channels\", \"8\", true))\n        .add_field(EmbedField::new(\"Server Boost Level\", \"Level 2\", true))\n        .add_field(EmbedField::new(\"Server Created\", \"2020-01-15\", true))\n        .footer(\"Server ID: 123456789012345678\")\n        .timestamp()\n}\n</code></pre>"},{"location":"examples/embeds/#user-profile-embed","title":"User Profile Embed","text":"<pre><code>fn create_user_profile_embed(message: &amp;Message) -&gt; Embed {\n    Embed::new()\n        .title(format!(\"\ud83d\udc64 User Profile: {}\", message.author.username))\n        .description(\"User information and statistics\")\n        .color(0xe91e63) // Pink\n        .thumbnail(&amp;message.author.avatar_url().unwrap_or_default())\n        .add_field(EmbedField::new(\"User ID\", &amp;message.author.id, false))\n        .add_field(EmbedField::new(\"Account Created\", \"2019-03-15\", true))\n        .add_field(EmbedField::new(\"Joined Server\", \"2020-06-20\", true))\n        .add_field(EmbedField::new(\"Roles\", \"Member, Active User\", false))\n        .add_field(EmbedField::new(\"Messages Sent\", \"2,847\", true))\n        .add_field(EmbedField::new(\"Last Active\", \"Today at 2:30 PM\", true))\n        .footer(&amp;format!(\"Requested by {}\", message.author.username))\n        .timestamp()\n}\n</code></pre>"},{"location":"examples/embeds/#error-embed","title":"Error Embed","text":"<pre><code>fn create_error_embed(error_message: &amp;str) -&gt; Embed {\n    Embed::new()\n        .title(\"\u274c Error\")\n        .description(error_message)\n        .color(0xe74c3c) // Red\n        .footer(\"If this error persists, contact an administrator\")\n        .timestamp()\n}\n</code></pre>"},{"location":"examples/embeds/#success-embed","title":"Success Embed","text":"<pre><code>fn create_success_embed(success_message: &amp;str) -&gt; Embed {\n    Embed::new()\n        .title(\"\u2705 Success\")\n        .description(success_message)\n        .color(0x2ecc71) // Green\n        .footer(\"Operation completed successfully\")\n        .timestamp()\n}\n</code></pre>"},{"location":"examples/embeds/#advanced-embed-handler","title":"Advanced Embed Handler","text":"<pre><code>struct AdvancedEmbedHandler;\n\n#[async_trait]\nimpl MessageHandler for AdvancedEmbedHandler {\n    async fn handle_message(&amp;self, message: &amp;Message) -&gt; Result&lt;Option&lt;String&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n        let parts: Vec&lt;&amp;str&gt; = message.content.split_whitespace().collect();\n\n        if parts.is_empty() || parts[0] != \"!embed\" {\n            return Ok(None);\n        }\n\n        let embed = match parts.get(1) {\n            Some(&amp;\"info\") =&gt; self.create_server_info_embed(message),\n            Some(&amp;\"profile\") =&gt; self.create_user_profile_embed(message),\n            Some(&amp;\"weather\") =&gt; self.create_weather_embed().await?,\n            Some(&amp;\"music\") =&gt; self.create_music_embed(),\n            Some(&amp;\"poll\") =&gt; self.create_poll_embed(&amp;parts[2..]),\n            Some(&amp;\"help\") =&gt; self.create_help_embed(),\n            _ =&gt; self.create_default_embed(),\n        };\n\n        // In a real implementation, you'd send this embed through the Discord API\n        Ok(Some(format!(\"Embed: {}\", embed.to_json())))\n    }\n}\n\nimpl AdvancedEmbedHandler {\n    fn create_server_info_embed(&amp;self, message: &amp;Message) -&gt; Embed {\n        Embed::new()\n            .title(\"\ud83c\udfe0 Server Information\")\n            .description(\"Detailed information about this Discord server\")\n            .color(0x7289da)\n            .add_field(EmbedField::new(\"Server Name\", \"My Awesome Server\", false))\n            .add_field(EmbedField::new(\"Total Members\", \"1,234\", true))\n            .add_field(EmbedField::new(\"Online Now\", \"567\", true))\n            .add_field(EmbedField::new(\"Text Channels\", \"25\", true))\n            .add_field(EmbedField::new(\"Voice Channels\", \"12\", true))\n            .add_field(EmbedField::new(\"Roles\", \"15\", true))\n            .add_field(EmbedField::new(\"Emojis\", \"89\", true))\n            .add_field(EmbedField::new(\"Server Owner\", \"&lt;@123456789&gt;\", false))\n            .add_field(EmbedField::new(\"Created On\", \"January 15, 2020\", false))\n            .thumbnail(\"https://example.com/server-icon.png\")\n            .footer(&amp;format!(\"Requested by {}\", message.author.username))\n            .timestamp()\n    }\n\n    fn create_user_profile_embed(&amp;self, message: &amp;Message) -&gt; Embed {\n        Embed::new()\n            .title(format!(\"\ud83d\udc64 {}'s Profile\", message.author.username))\n            .color(0x9b59b6)\n            .add_field(EmbedField::new(\"Username\", &amp;message.author.username, true))\n            .add_field(EmbedField::new(\"User ID\", &amp;message.author.id, true))\n            .add_field(EmbedField::new(\"Status\", \"\ud83d\udfe2 Online\", true))\n            .add_field(EmbedField::new(\"Join Date\", \"June 20, 2020\", true))\n            .add_field(EmbedField::new(\"Account Age\", \"3 years, 7 months\", true))\n            .add_field(EmbedField::new(\"Roles\", \"Member, Active User, Helper\", false))\n            .thumbnail(&amp;message.author.avatar_url().unwrap_or_default())\n            .footer(\"User Profile\")\n            .timestamp()\n    }\n\n    async fn create_weather_embed(&amp;self) -&gt; Result&lt;Embed, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n        // In a real implementation, you'd fetch weather data from an API\n        Ok(Embed::new()\n            .title(\"\ud83c\udf24\ufe0f Weather Forecast\")\n            .description(\"Current weather conditions\")\n            .color(0x87ceeb)\n            .add_field(EmbedField::new(\"Location\", \"San Francisco, CA\", false))\n            .add_field(EmbedField::new(\"Temperature\", \"22\u00b0C (72\u00b0F)\", true))\n            .add_field(EmbedField::new(\"Condition\", \"Partly Cloudy\", true))\n            .add_field(EmbedField::new(\"Humidity\", \"65%\", true))\n            .add_field(EmbedField::new(\"Wind\", \"15 mph NW\", true))\n            .add_field(EmbedField::new(\"UV Index\", \"6 (High)\", true))\n            .add_field(EmbedField::new(\"Visibility\", \"10 km\", true))\n            .thumbnail(\"https://example.com/weather-icon.png\")\n            .footer(\"Weather data provided by OpenWeatherMap\")\n            .timestamp())\n    }\n\n    fn create_music_embed(&amp;self) -&gt; Embed {\n        Embed::new()\n            .title(\"\ud83c\udfb5 Now Playing\")\n            .description(\"Current music queue status\")\n            .color(0xff6b6b)\n            .add_field(EmbedField::new(\"Song\", \"Never Gonna Give You Up\", false))\n            .add_field(EmbedField::new(\"Artist\", \"Rick Astley\", true))\n            .add_field(EmbedField::new(\"Duration\", \"3:33\", true))\n            .add_field(EmbedField::new(\"Requested by\", \"&lt;@123456789&gt;\", true))\n            .add_field(EmbedField::new(\"Queue Position\", \"1 of 5\", true))\n            .add_field(EmbedField::new(\"Volume\", \"75%\", true))\n            .add_field(EmbedField::new(\"Loop\", \"Disabled\", true))\n            .thumbnail(\"https://example.com/album-art.jpg\")\n            .footer(\"Music Player | Use !music help for commands\")\n            .timestamp()\n    }\n\n    fn create_poll_embed(&amp;self, options: &amp;[&amp;str]) -&gt; Embed {\n        let mut embed = Embed::new()\n            .title(\"\ud83d\udcca Poll\")\n            .description(\"Vote by reacting with the corresponding emoji!\")\n            .color(0xf39c12);\n\n        let emojis = [\"1\ufe0f\u20e3\", \"2\ufe0f\u20e3\", \"3\ufe0f\u20e3\", \"4\ufe0f\u20e3\", \"5\ufe0f\u20e3\", \"6\ufe0f\u20e3\", \"7\ufe0f\u20e3\", \"8\ufe0f\u20e3\", \"9\ufe0f\u20e3\", \"\ud83d\udd1f\"];\n\n        for (i, option) in options.iter().take(10).enumerate() {\n            embed = embed.add_field(EmbedField::new(\n                &amp;format!(\"{} Option {}\", emojis[i], i + 1),\n                option,\n                false\n            ));\n        }\n\n        embed\n            .footer(\"React to vote! Poll ends in 24 hours.\")\n            .timestamp()\n    }\n\n    fn create_help_embed(&amp;self) -&gt; Embed {\n        Embed::new()\n            .title(\"\ud83d\udcda Embed Commands Help\")\n            .description(\"Available embed commands and their usage\")\n            .color(0x3498db)\n            .add_field(EmbedField::new(\"!embed info\", \"Show server information\", false))\n            .add_field(EmbedField::new(\"!embed profile\", \"Show your user profile\", false))\n            .add_field(EmbedField::new(\"!embed weather\", \"Get weather information\", false))\n            .add_field(EmbedField::new(\"!embed music\", \"Show music player status\", false))\n            .add_field(EmbedField::new(\"!embed poll &lt;options&gt;\", \"Create a poll with options\", false))\n            .add_field(EmbedField::new(\"!embed help\", \"Show this help message\", false))\n            .footer(\"Use these commands to see different embed examples\")\n            .timestamp()\n    }\n\n    fn create_default_embed(&amp;self) -&gt; Embed {\n        Embed::new()\n            .title(\"\ud83e\udd16 RustyCord Bot\")\n            .description(\"Welcome to the embed system demonstration!\")\n            .color(0x7289da)\n            .add_field(EmbedField::new(\"Available Commands\", \"Use `!embed help` to see all commands\", false))\n            .add_field(EmbedField::new(\"Bot Version\", \"0.1.1\", true))\n            .add_field(EmbedField::new(\"Language\", \"Rust\", true))\n            .add_field(EmbedField::new(\"Library\", \"RustyCord\", true))\n            .footer(\"RustyCord - Fast, Safe, Reliable\")\n            .timestamp()\n    }\n}\n</code></pre>"},{"location":"examples/embeds/#embed-builder-pattern","title":"Embed Builder Pattern","text":"<pre><code>// Fluent interface for building embeds\nlet embed = Embed::new()\n    .title(\"My Embed\")\n    .description(\"A description\")\n    .url(\"https://example.com\")\n    .color(0x00ff00)\n    .author(\"Author Name\", Some(\"https://example.com\"), Some(\"https://example.com/icon.png\"))\n    .thumbnail(\"https://example.com/thumbnail.png\")\n    .image(\"https://example.com/image.png\")\n    .add_field(EmbedField::new(\"Field 1\", \"Value 1\", true))\n    .add_field(EmbedField::new(\"Field 2\", \"Value 2\", true))\n    .footer(\"Footer text\")\n    .timestamp();\n</code></pre>"},{"location":"examples/embeds/#best-practices","title":"Best Practices","text":"<ol> <li>Color Coding: Use consistent colors for different types of messages</li> <li>Success: Green (<code>0x2ecc71</code>)</li> <li>Error: Red (<code>0xe74c3c</code>)</li> <li>Info: Blue (<code>0x3498db</code>)</li> <li> <p>Warning: Orange (<code>0xf39c12</code>)</p> </li> <li> <p>Field Limits: Discord embeds have limits:</p> </li> <li>Title: 256 characters</li> <li>Description: 4096 characters</li> <li>Fields: 25 fields maximum</li> <li>Field name: 256 characters</li> <li> <p>Field value: 1024 characters</p> </li> <li> <p>Image Guidelines:</p> </li> <li>Use HTTPS URLs for images</li> <li>Keep image sizes reasonable</li> <li> <p>Provide fallback text for accessibility</p> </li> <li> <p>Timestamps: Always include timestamps for time-sensitive information</p> </li> <li> <p>Footer Information: Use footers for metadata and attribution</p> </li> </ol>"},{"location":"examples/embeds/#testing-embeds","title":"Testing Embeds","text":"<pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_embed_creation() {\n        let embed = Embed::new()\n            .title(\"Test Embed\")\n            .description(\"Test Description\")\n            .color(0x00ff00);\n\n        assert_eq!(embed.title(), Some(\"Test Embed\"));\n        assert_eq!(embed.description(), Some(\"Test Description\"));\n        assert_eq!(embed.color(), Some(0x00ff00));\n    }\n}\n</code></pre>"},{"location":"examples/embeds/#related-examples","title":"Related Examples","text":"<ul> <li>Message Handler Example - Using embeds in message handlers</li> <li>API Integration - Fetching data for embeds</li> <li>User Guide - Command patterns with embeds</li> </ul>"},{"location":"examples/logging/","title":"Logging Example","text":"<p>Comprehensive guide to logging in rustycord applications.</p>"},{"location":"examples/logging/#overview","title":"Overview","text":"<p>RustyCord provides a sophisticated logging system built on top of Rust's <code>log</code> crate with <code>fern</code> for configuration. The logging system supports multiple output targets, log levels, and custom formatting.</p>"},{"location":"examples/logging/#basic-logging-setup","title":"Basic Logging Setup","text":"<pre><code>use rustycord::{Bot, logger};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Basic logging setup\n    logger::setup_logger(\"info\".to_string())?;\n\n    log::info!(\"\ud83d\ude80 Starting RustyCord bot...\");\n\n    let token = std::env::var(\"DISCORD_TOKEN\")?;\n    let mut bot = Bot::new(None).await;\n\n    log::info!(\"\ud83d\udd11 Logging in to Discord...\");\n    let user_response = bot.login(token).await;\n    log::info!(\"\u2705 Logged in as: {}\", user_response.username);\n\n    log::info!(\"\ud83c\udfaf Starting bot event loop...\");\n    bot.start().await?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"examples/logging/#log-levels","title":"Log Levels","text":"<p>RustyCord supports five log levels:</p> <pre><code>use log::{trace, debug, info, warn, error};\n\n// TRACE: Very detailed information, typically only of interest when diagnosing problems\ntrace!(\"\ud83d\udd0d Processing message ID: {}\", message.id);\n\n// DEBUG: Detailed information, typically only of interest when diagnosing problems\ndebug!(\"\ud83d\udc1b Message handler executed: {}\", handler_name);\n\n// INFO: General information about program execution\ninfo!(\"\ud83d\udce2 Bot connected to Discord Gateway\");\n\n// WARN: Something unexpected happened, but the program can continue\nwarn!(\"\u26a0\ufe0f Rate limit approaching for endpoint: {}\", endpoint);\n\n// ERROR: Serious problems that might cause the program to abort\nerror!(\"\u274c Failed to send message: {}\", error);\n</code></pre>"},{"location":"examples/logging/#advanced-logging-configuration","title":"Advanced Logging Configuration","text":"<pre><code>use rustycord::logger;\nuse log::LevelFilter;\nuse fern::Dispatch;\nuse chrono::Local;\n\nfn setup_advanced_logging() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    Dispatch::new()\n        .format(|out, message, record| {\n            out.finish(format_args!(\n                \"{}[{}][{}] {}\",\n                Local::now().format(\"%Y-%m-%d %H:%M:%S\"),\n                record.target(),\n                record.level(),\n                message\n            ))\n        })\n        .level(LevelFilter::Info)\n        .level_for(\"rustycord::gateway\", LevelFilter::Debug)\n        .level_for(\"rustycord::http\", LevelFilter::Warn)\n        .chain(std::io::stdout())\n        .chain(fern::log_file(\"bot.log\")?)\n        .apply()?;\n\n    Ok(())\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    setup_advanced_logging()?;\n\n    log::info!(\"\ud83d\ude80 Bot starting with advanced logging...\");\n\n    // Your bot code here...\n\n    Ok(())\n}\n</code></pre>"},{"location":"examples/logging/#structured-logging","title":"Structured Logging","text":"<pre><code>use serde_json::json;\n\n// Structured logging for better analytics\nfn log_command_execution(user_id: &amp;str, command: &amp;str, execution_time: u64, success: bool) {\n    let log_data = json!({\n        \"event\": \"command_execution\",\n        \"user_id\": user_id,\n        \"command\": command,\n        \"execution_time_ms\": execution_time,\n        \"success\": success,\n        \"timestamp\": chrono::Utc::now().to_rfc3339()\n    });\n\n    if success {\n        info!(\"Command executed: {}\", log_data);\n    } else {\n        warn!(\"Command failed: {}\", log_data);\n    }\n}\n\n// Usage in message handler\n#[async_trait]\nimpl MessageHandler for LoggingHandler {\n    async fn handle_message(&amp;self, message: &amp;Message) -&gt; Result&lt;Option&lt;String&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n        let start_time = std::time::Instant::now();\n\n        if message.content.starts_with(\"!test\") {\n            debug!(\"\ud83e\uddea Processing test command from user: {}\", message.author.username);\n\n            let result = self.process_test_command(message).await;\n            let execution_time = start_time.elapsed().as_millis() as u64;\n\n            log_command_execution(\n                &amp;message.author.id,\n                \"test\",\n                execution_time,\n                result.is_ok()\n            );\n\n            result\n        } else {\n            Ok(None)\n        }\n    }\n}\n</code></pre>"},{"location":"examples/logging/#file-logging-with-rotation","title":"File Logging with Rotation","text":"<pre><code>use fern::Dispatch;\nuse log::LevelFilter;\nuse chrono::Local;\nuse std::fs;\n\nfn setup_file_logging() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Create logs directory if it doesn't exist\n    fs::create_dir_all(\"logs\")?;\n\n    let log_filename = format!(\"logs/bot-{}.log\", Local::now().format(\"%Y-%m-%d\"));\n\n    Dispatch::new()\n        .format(|out, message, record| {\n            out.finish(format_args!(\n                \"{} [{}] [{}:{}] {}\",\n                Local::now().format(\"%Y-%m-%d %H:%M:%S%.3f\"),\n                record.level(),\n                record.file().unwrap_or(\"unknown\"),\n                record.line().unwrap_or(0),\n                message\n            ))\n        })\n        .level(LevelFilter::Info)\n        .chain(\n            Dispatch::new()\n                .filter(|metadata| metadata.target().starts_with(\"rustycord\"))\n                .chain(fern::log_file(&amp;log_filename)?)\n        )\n        .chain(\n            Dispatch::new()\n                .level(LevelFilter::Warn)\n                .chain(std::io::stderr())\n        )\n        .apply()?;\n\n    info!(\"\ud83d\udcc1 Logging to file: {}\", log_filename);\n    Ok(())\n}\n</code></pre>"},{"location":"examples/logging/#performance-logging","title":"Performance Logging","text":"<pre><code>use std::time::Instant;\n\nstruct PerformanceLogger;\n\nimpl PerformanceLogger {\n    fn log_function_duration&lt;F, R&gt;(func_name: &amp;str, f: F) -&gt; R\n    where\n        F: FnOnce() -&gt; R,\n    {\n        let start = Instant::now();\n        let result = f();\n        let duration = start.elapsed();\n\n        if duration.as_millis() &gt; 100 {\n            warn!(\"\u23f1\ufe0f Slow operation: {} took {}ms\", func_name, duration.as_millis());\n        } else {\n            debug!(\"\u26a1 Fast operation: {} took {}ms\", func_name, duration.as_millis());\n        }\n\n        result\n    }\n\n    async fn log_async_duration&lt;F, Fut, R&gt;(func_name: &amp;str, f: F) -&gt; R\n    where\n        F: FnOnce() -&gt; Fut,\n        Fut: std::future::Future&lt;Output = R&gt;,\n    {\n        let start = Instant::now();\n        let result = f().await;\n        let duration = start.elapsed();\n\n        info!(\"\ud83d\ude80 Async operation: {} completed in {}ms\", func_name, duration.as_millis());\n        result\n    }\n}\n\n// Usage example\nimpl MessageHandler for PerformanceMonitoringHandler {\n    async fn handle_message(&amp;self, message: &amp;Message) -&gt; Result&lt;Option&lt;String&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n        if message.content == \"!performance\" {\n            let result = PerformanceLogger::log_async_duration(\"database_query\", || async {\n                // Simulate database query\n                tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;\n                \"Query completed\"\n            }).await;\n\n            Ok(Some(format!(\"Performance test: {}\", result)))\n        } else {\n            Ok(None)\n        }\n    }\n}\n</code></pre>"},{"location":"examples/logging/#error-logging-with-context","title":"Error Logging with Context","text":"<pre><code>use anyhow::{Context, Result};\n\nasync fn process_user_command(message: &amp;Message) -&gt; Result&lt;String&gt; {\n    debug!(\"\ud83d\udd04 Processing command from user: {}\", message.author.username);\n\n    let user_data = fetch_user_data(&amp;message.author.id)\n        .await\n        .with_context(|| format!(\"Failed to fetch data for user {}\", message.author.id))?;\n\n    let processed_data = process_data(user_data)\n        .with_context(|| \"Failed to process user data\")?;\n\n    info!(\"\u2705 Successfully processed command for user: {}\", message.author.username);\n    Ok(processed_data)\n}\n\nasync fn fetch_user_data(user_id: &amp;str) -&gt; Result&lt;String&gt; {\n    // Simulate potential failure\n    if user_id == \"error_user\" {\n        error!(\"\u274c Simulated error for user: {}\", user_id);\n        anyhow::bail!(\"User not found in database\");\n    }\n\n    debug!(\"\ud83d\udcca Fetched data for user: {}\", user_id);\n    Ok(format!(\"data_for_{}\", user_id))\n}\n\nfn process_data(data: String) -&gt; Result&lt;String&gt; {\n    if data.contains(\"invalid\") {\n        error!(\"\u274c Invalid data format: {}\", data);\n        anyhow::bail!(\"Invalid data format\");\n    }\n\n    debug!(\"\ud83d\udd04 Processing data: {}\", data);\n    Ok(format!(\"processed_{}\", data))\n}\n</code></pre>"},{"location":"examples/logging/#logging-best-practices","title":"Logging Best Practices","text":""},{"location":"examples/logging/#1-use-appropriate-log-levels","title":"1. Use Appropriate Log Levels","text":"<pre><code>// \u2705 Good: Appropriate log levels\ndebug!(\"\ud83d\udd0d Validating message format\");\ninfo!(\"\ud83d\udce2 User {} joined the server\", username);\nwarn!(\"\u26a0\ufe0f Rate limit reached, slowing down requests\");\nerror!(\"\u274c Failed to connect to database: {}\", error);\n\n// \u274c Bad: Wrong log levels\nerror!(\"User sent a message\"); // This should be debug or trace\ninfo!(\"Database connection failed\"); // This should be error\n</code></pre>"},{"location":"examples/logging/#2-include-context","title":"2. Include Context","text":"<pre><code>// \u2705 Good: Includes relevant context\ninfo!(\"\ud83d\udce8 Message received in #{} from {}: {}\", \n      channel_name, username, message_preview);\nwarn!(\"\u26a0\ufe0f Rate limit hit for endpoint {} (remaining: {})\", \n      endpoint, remaining_requests);\n\n// \u274c Bad: No context\ninfo!(\"Message received\");\nwarn!(\"Rate limit hit\");\n</code></pre>"},{"location":"examples/logging/#3-use-emojis-for-visual-scanning","title":"3. Use Emojis for Visual Scanning","text":"<pre><code>trace!(\"\ud83d\udd0d Detailed debug info\");\ndebug!(\"\ud83d\udc1b Debug information\");\ninfo!(\"\ud83d\udce2 General information\");\nwarn!(\"\u26a0\ufe0f Warning message\");\nerror!(\"\u274c Error occurred\");\n</code></pre>"},{"location":"examples/logging/#4-log-structured-data","title":"4. Log Structured Data","text":"<pre><code>// For important events, log structured data\ninfo!(\n    \"user_action\"; \n    \"user_id\" =&gt; %user.id,\n    \"action\" =&gt; \"message_sent\",\n    \"channel_id\" =&gt; %channel.id,\n    \"message_length\" =&gt; message.content.len(),\n    \"timestamp\" =&gt; %chrono::Utc::now()\n);\n</code></pre>"},{"location":"examples/logging/#production-logging-setup","title":"Production Logging Setup","text":"<pre><code>use fern::Dispatch;\nuse log::LevelFilter;\n\npub fn setup_production_logging() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let log_level = std::env::var(\"LOG_LEVEL\")\n        .unwrap_or_else(|_| \"info\".to_string())\n        .to_lowercase();\n\n    let level = match log_level.as_str() {\n        \"trace\" =&gt; LevelFilter::Trace,\n        \"debug\" =&gt; LevelFilter::Debug,\n        \"info\" =&gt; LevelFilter::Info,\n        \"warn\" =&gt; LevelFilter::Warn,\n        \"error\" =&gt; LevelFilter::Error,\n        _ =&gt; LevelFilter::Info,\n    };\n\n    Dispatch::new()\n        .format(|out, message, record| {\n            out.finish(format_args!(\n                \"{} [{}] [{}] {}\",\n                chrono::Utc::now().to_rfc3339(),\n                record.level(),\n                record.target(),\n                message\n            ))\n        })\n        .level(level)\n        // Reduce noise from dependencies\n        .level_for(\"hyper\", LevelFilter::Warn)\n        .level_for(\"reqwest\", LevelFilter::Warn)\n        .level_for(\"tungstenite\", LevelFilter::Warn)\n        // File output for persistent logs\n        .chain(fern::log_file(\"bot.log\")?)\n        // Console output for immediate feedback\n        .chain(std::io::stdout())\n        .apply()?;\n\n    info!(\"\ud83d\ude80 Logging initialized at level: {}\", log_level);\n    Ok(())\n}\n</code></pre>"},{"location":"examples/logging/#monitoring-and-alerts","title":"Monitoring and Alerts","text":"<pre><code>use std::sync::atomic::{AtomicU64, Ordering};\nuse std::sync::Arc;\n\npub struct LoggingMetrics {\n    error_count: AtomicU64,\n    warn_count: AtomicU64,\n    last_error_time: AtomicU64,\n}\n\nimpl LoggingMetrics {\n    pub fn new() -&gt; Arc&lt;Self&gt; {\n        Arc::new(Self {\n            error_count: AtomicU64::new(0),\n            warn_count: AtomicU64::new(0),\n            last_error_time: AtomicU64::new(0),\n        })\n    }\n\n    pub fn record_error(&amp;self) {\n        self.error_count.fetch_add(1, Ordering::Relaxed);\n        self.last_error_time.store(\n            chrono::Utc::now().timestamp() as u64,\n            Ordering::Relaxed\n        );\n\n        let error_count = self.error_count.load(Ordering::Relaxed);\n        if error_count % 10 == 0 {\n            warn!(\"\ud83d\udea8 High error rate detected: {} errors\", error_count);\n        }\n    }\n\n    pub fn record_warning(&amp;self) {\n        self.warn_count.fetch_add(1, Ordering::Relaxed);\n    }\n\n    pub fn get_stats(&amp;self) -&gt; (u64, u64, u64) {\n        (\n            self.error_count.load(Ordering::Relaxed),\n            self.warn_count.load(Ordering::Relaxed),\n            self.last_error_time.load(Ordering::Relaxed),\n        )\n    }\n}\n</code></pre>"},{"location":"examples/logging/#testing-logging","title":"Testing Logging","text":"<pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n    use log::Level;\n\n    #[test]\n    fn test_logging_setup() {\n        // Test that logging can be initialized\n        assert!(logger::setup_logger(\"debug\".to_string()).is_ok());\n\n        // Test logging at different levels\n        log::debug!(\"Test debug message\");\n        log::info!(\"Test info message\");\n        log::warn!(\"Test warning message\");\n        log::error!(\"Test error message\");\n    }\n\n    #[test]\n    fn test_log_levels() {\n        let levels = vec![\"trace\", \"debug\", \"info\", \"warn\", \"error\"];\n\n        for level in levels {\n            assert!(logger::setup_logger(level.to_string()).is_ok());\n        }\n    }\n}\n</code></pre>"},{"location":"examples/logging/#related-documentation","title":"Related Documentation","text":"<ul> <li>Basic Bot Example - Simple logging usage</li> <li>Message Handler Example - Logging in handlers</li> <li>Error Handling Guide - Error logging patterns</li> </ul>"},{"location":"examples/message-handler/","title":"Message Handler Example","text":"<p>This example shows how to create custom message handlers for more complex bot interactions.</p>"},{"location":"examples/message-handler/#overview","title":"Overview","text":"<p>Message handlers in rustycord allow you to create modular, reusable components that process Discord messages. Each handler implements the <code>MessageHandler</code> trait and can be registered with your bot.</p>"},{"location":"examples/message-handler/#basic-message-handler","title":"Basic Message Handler","text":"<pre><code>use rustycord::{Bot, MessageHandler, logger};\nuse rustycord::models::Message;\nuse async_trait::async_trait;\nuse std::collections::HashMap;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    logger::setup_logger(\"info\".to_string())?;\n\n    let token = std::env::var(\"DISCORD_TOKEN\")?;\n    let mut bot = Bot::new(None).await;\n\n    bot.login(token).await;\n\n    // Register multiple handlers\n    bot.register_message_handler(Box::new(MathHandler));\n    bot.register_message_handler(Box::new(InfoHandler));\n    bot.register_message_handler(Box::new(ModeratorHandler));\n\n    bot.start().await?;\n    Ok(())\n}\n</code></pre>"},{"location":"examples/message-handler/#math-handler","title":"Math Handler","text":"<p>A handler that performs basic math operations:</p> <pre><code>struct MathHandler;\n\n#[async_trait]\nimpl MessageHandler for MathHandler {\n    async fn handle_message(&amp;self, message: &amp;Message) -&gt; Result&lt;Option&lt;String&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n        if message.content.starts_with(\"!math \") {\n            let expression = message.content.strip_prefix(\"!math \").unwrap_or(\"\");\n\n            match evaluate_expression(expression) {\n                Ok(result) =&gt; Ok(Some(format!(\"\ud83e\uddee Result: {}\", result))),\n                Err(e) =&gt; Ok(Some(format!(\"\u274c Error: {}\", e)))\n            }\n        } else {\n            Ok(None)\n        }\n    }\n}\n\nfn evaluate_expression(expr: &amp;str) -&gt; Result&lt;f64, String&gt; {\n    // Simple expression evaluator (you might want to use a proper parser)\n    let parts: Vec&lt;&amp;str&gt; = expr.split_whitespace().collect();\n\n    if parts.len() != 3 {\n        return Err(\"Usage: !math &lt;number&gt; &lt;operator&gt; &lt;number&gt;\".to_string());\n    }\n\n    let a: f64 = parts[0].parse().map_err(|_| \"Invalid first number\")?;\n    let op = parts[1];\n    let b: f64 = parts[2].parse().map_err(|_| \"Invalid second number\")?;\n\n    match op {\n        \"+\" =&gt; Ok(a + b),\n        \"-\" =&gt; Ok(a - b),\n        \"*\" =&gt; Ok(a * b),\n        \"/\" =&gt; {\n            if b == 0.0 {\n                Err(\"Division by zero\".to_string())\n            } else {\n                Ok(a / b)\n            }\n        },\n        \"%\" =&gt; Ok(a % b),\n        \"^\" =&gt; Ok(a.powf(b)),\n        _ =&gt; Err(\"Supported operators: +, -, *, /, %, ^\".to_string())\n    }\n}\n</code></pre>"},{"location":"examples/message-handler/#info-handler","title":"Info Handler","text":"<p>A handler that provides server and user information:</p> <pre><code>struct InfoHandler;\n\n#[async_trait]\nimpl MessageHandler for InfoHandler {\n    async fn handle_message(&amp;self, message: &amp;Message) -&gt; Result&lt;Option&lt;String&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n        match message.content.as_str() {\n            \"!info server\" =&gt; {\n                Ok(Some(format!(\n                    \"\ud83c\udfe0 **Server Information**\\n\\\n                     Guild ID: {}\\n\\\n                     Channel ID: {}\",\n                    message.guild_id.unwrap_or_default(),\n                    message.channel_id\n                )))\n            },\n            \"!info user\" =&gt; {\n                Ok(Some(format!(\n                    \"\ud83d\udc64 **User Information**\\n\\\n                     Username: {}\\n\\\n                     User ID: {}\\n\\\n                     Mention: &lt;@{}&gt;\",\n                    message.author.username,\n                    message.author.id,\n                    message.author.id\n                )))\n            },\n            \"!help\" =&gt; {\n                Ok(Some(\n                    \"\ud83d\udcda **Available Commands**\\n\\\n                     `!info server` - Server information\\n\\\n                     `!info user` - Your user information\\n\\\n                     `!math &lt;a&gt; &lt;op&gt; &lt;b&gt;` - Basic math operations\\n\\\n                     `!help` - Show this help message\".to_string()\n                ))\n            },\n            _ =&gt; Ok(None)\n        }\n    }\n}\n</code></pre>"},{"location":"examples/message-handler/#stateful-handler","title":"Stateful Handler","text":"<p>A handler that maintains state between messages:</p> <pre><code>use std::sync::{Arc, Mutex};\n\nstruct CounterHandler {\n    counters: Arc&lt;Mutex&lt;HashMap&lt;String, u32&gt;&gt;&gt;,\n}\n\nimpl CounterHandler {\n    fn new() -&gt; Self {\n        Self {\n            counters: Arc::new(Mutex::new(HashMap::new())),\n        }\n    }\n}\n\n#[async_trait]\nimpl MessageHandler for CounterHandler {\n    async fn handle_message(&amp;self, message: &amp;Message) -&gt; Result&lt;Option&lt;String&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n        if message.content.starts_with(\"!count\") {\n            let mut counters = self.counters.lock().unwrap();\n            let user_id = message.author.id.to_string();\n\n            let count = counters.entry(user_id.clone()).or_insert(0);\n            *count += 1;\n\n            Ok(Some(format!(\"\ud83d\udcca {}, your message count: {}\", message.author.username, count)))\n        } else {\n            Ok(None)\n        }\n    }\n}\n</code></pre>"},{"location":"examples/message-handler/#moderator-handler","title":"Moderator Handler","text":"<p>A handler with permission checks:</p> <pre><code>struct ModeratorHandler;\n\n#[async_trait]\nimpl MessageHandler for ModeratorHandler {\n    async fn handle_message(&amp;self, message: &amp;Message) -&gt; Result&lt;Option&lt;String&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n        if message.content.starts_with(\"!mod \") {\n            // Note: In a real implementation, you'd check actual Discord permissions\n            if !self.is_moderator(&amp;message.author) {\n                return Ok(Some(\"\u274c You don't have permission to use moderator commands.\".to_string()));\n            }\n\n            let command = message.content.strip_prefix(\"!mod \").unwrap_or(\"\");\n\n            match command {\n                \"clean\" =&gt; {\n                    Ok(Some(\"\ud83e\uddf9 Cleaned up recent messages.\".to_string()))\n                },\n                \"warn\" =&gt; {\n                    Ok(Some(\"\u26a0\ufe0f Warning issued.\".to_string()))\n                },\n                _ =&gt; {\n                    Ok(Some(\"\u2753 Unknown moderator command. Available: clean, warn\".to_string()))\n                }\n            }\n        } else {\n            Ok(None)\n        }\n    }\n}\n\nimpl ModeratorHandler {\n    fn is_moderator(&amp;self, user: &amp;rustycord::models::User) -&gt; bool {\n        // Simplified check - in reality, you'd check Discord roles/permissions\n        // For demo purposes, we'll check if the username contains \"mod\"\n        user.username.to_lowercase().contains(\"mod\")\n    }\n}\n</code></pre>"},{"location":"examples/message-handler/#handler-registration","title":"Handler Registration","text":"<pre><code>// Register handlers in your main function\nasync fn setup_bot() -&gt; Result&lt;Bot, Box&lt;dyn std::error::Error&gt;&gt; {\n    let mut bot = Bot::new(None).await;\n\n    // Basic handlers\n    bot.register_message_handler(Box::new(MathHandler));\n    bot.register_message_handler(Box::new(InfoHandler));\n    bot.register_message_handler(Box::new(ModeratorHandler));\n\n    // Stateful handler\n    bot.register_message_handler(Box::new(CounterHandler::new()));\n\n    Ok(bot)\n}\n</code></pre>"},{"location":"examples/message-handler/#best-practices","title":"Best Practices","text":"<ol> <li>Keep handlers focused: Each handler should have a single responsibility</li> <li>Use async operations: Make database calls or HTTP requests async</li> <li>Handle errors gracefully: Return meaningful error messages to users</li> <li>Validate input: Always validate user input before processing</li> <li>Use proper permissions: Check user permissions for sensitive commands</li> <li>State management: Use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> for shared state between handler instances</li> </ol>"},{"location":"examples/message-handler/#advanced-examples","title":"Advanced Examples","text":"<ul> <li>Embeds Example - Rich embed responses</li> <li>Database Integration - Persistent data storage</li> <li>API Integration - Calling external APIs</li> </ul>"},{"location":"examples/message-handler/#testing","title":"Testing","text":"<pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n    use rustycord::models::{User, Message};\n\n    #[tokio::test]\n    async fn test_math_handler() {\n        let handler = MathHandler;\n        let message = Message {\n            content: \"!math 5 + 3\".to_string(),\n            author: User {\n                id: \"123\".to_string(),\n                username: \"testuser\".to_string(),\n            },\n            // ... other fields\n        };\n\n        let result = handler.handle_message(&amp;message).await.unwrap();\n        assert_eq!(result, Some(\"\ud83e\uddee Result: 8\".to_string()));\n    }\n}\n</code></pre>"},{"location":"getting-started/first-bot/","title":"Your First Bot","text":"<p>This guide will walk you through creating your first Discord bot with rustycord, from setup to deployment.</p> <p>Development Library Notice</p> <p>Remember that rustycord is in heavy development. This tutorial is for learning and experimentation only. Do not use the resulting bot in production environments.</p>"},{"location":"getting-started/first-bot/#prerequisites","title":"Prerequisites","text":"<p>Make sure you have completed the installation guide before proceeding.</p>"},{"location":"getting-started/first-bot/#creating-a-simple-echo-bot","title":"Creating a Simple Echo Bot","text":"<p>Let's start with a basic bot that echoes messages back to users.</p>"},{"location":"getting-started/first-bot/#step-1-set-up-your-project","title":"Step 1: Set Up Your Project","text":"<pre><code>cargo new my-first-bot\ncd my-first-bot\n</code></pre>"},{"location":"getting-started/first-bot/#step-2-add-dependencies","title":"Step 2: Add Dependencies","text":"<p>Edit your <code>Cargo.toml</code>:</p> <pre><code>[package]\nname = \"my-first-bot\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nrustycord = \"0.1.0\"\ntokio = { version = \"1.40\", features = [\"full\"] }\nasync-trait = \"0.1\"\ndotenv = \"0.15\"\n</code></pre>"},{"location":"getting-started/first-bot/#step-3-create-your-bot","title":"Step 3: Create Your Bot","text":"<p>Replace the contents of <code>src/main.rs</code>:</p> <pre><code>use async_trait::async_trait;\nuse rustycord::{\n    bot::BotBase,\n    handlers::message_handler::MessageHandler,\n    message::ChannelMessage,\n    client::Client,\n    logger\n};\n\n// Simple echo handler\nstruct EchoHandler;\n\n#[async_trait]\nimpl MessageHandler for EchoHandler {\n    async fn on_message_create(\n        &amp;self, \n        message: &amp;ChannelMessage, \n        client: &amp;Client\n    ) -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n        // Don't respond to bot messages (avoid infinite loops!)\n        if message.author.bot.unwrap_or(false) {\n            return Ok(());\n        }\n\n        // Only respond to messages that start with \"!echo\"\n        if message.content.starts_with(\"!echo \") {\n            let echo_text = &amp;message.content[6..]; // Remove \"!echo \" prefix\n            client.send_text_message(&amp;message.channel_id, echo_text).await?;\n        }\n\n        Ok(())\n    }\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Load environment variables\n    dotenv::dotenv().ok();\n\n    // Initialize logging\n    logger::setup_logger(\"info\".to_string())?;\n\n    // Get bot token\n    let token = std::env::var(\"DISCORD_TOKEN\")\n        .expect(\"DISCORD_TOKEN environment variable not set\");\n\n    println!(\"\ud83d\ude80 Starting your first Discord bot!\");\n\n    // Create and login bot\n    let mut bot = BotBase::new(None).await;\n    let user_info = bot.login(token).await;\n    println!(\"\ud83d\udd11 Logged in as: {}\", user_info.username);\n\n    // Register message handler\n    if let Some(client) = &amp;bot.client {\n        let event_dispatcher = client.get_event_dispatcher();\n        let message_handlers = event_dispatcher.get_message_handlers();\n\n        message_handlers.add_handler(EchoHandler).await;\n        println!(\"\ud83d\udcdd Echo handler registered!\");\n    }\n\n    println!(\"\ud83e\udd16 Bot is running! Try typing '!echo Hello World' in Discord\");\n\n    // Connect to Discord\n    bot.connect(bot.intents, Some(true)).await;\n\n    // Keep the bot running\n    loop {\n        tokio::time::sleep(tokio::time::Duration::from_secs(60)).await;\n    }\n}\n</code></pre>"},{"location":"getting-started/first-bot/#step-4-set-up-environment-variables","title":"Step 4: Set Up Environment Variables","text":"<p>Create a <code>.env</code> file:</p> <pre><code>DISCORD_TOKEN=your_bot_token_here\n</code></pre> <p>Remember to replace <code>your_bot_token_here</code> with your actual bot token from the Discord Developer Portal.</p>"},{"location":"getting-started/first-bot/#step-5-run-your-bot","title":"Step 5: Run Your Bot","text":"<pre><code>cargo run\n</code></pre> <p>You should see output like:</p> <pre><code>\ud83d\ude80 Starting your first Discord bot!\n\ud83d\udd11 Logged in as: YourBot#1234\n\ud83d\udcdd Echo handler registered!\n\ud83e\udd16 Bot is running! Try typing '!echo Hello World' in Discord\n</code></pre>"},{"location":"getting-started/first-bot/#step-6-test-your-bot","title":"Step 6: Test Your Bot","text":"<ol> <li>Go to your Discord server where you invited the bot</li> <li>Type: <code>!echo Hello World</code></li> <li>Your bot should respond with: <code>Hello World</code></li> </ol>"},{"location":"getting-started/first-bot/#adding-more-commands","title":"Adding More Commands","text":"<p>Let's enhance our bot with multiple commands using the prefix system:</p> <pre><code>use async_trait::async_trait;\nuse rustycord::{\n    bot::BotBase,\n    handlers::message_handler::MessageHandler,\n    prefix::{PrefixListener, PrefixCommand, HelpCommand, PingCommand},\n    message::ChannelMessage,\n    client::Client,\n    logger\n};\nuse std::sync::Arc;\n\n// Custom greeting command\nstruct GreetCommand;\n\n#[async_trait]\nimpl PrefixCommand for GreetCommand {\n    async fn execute(&amp;self, message: &amp;ChannelMessage, args: Vec&lt;&amp;str&gt;) \n        -&gt; Result&lt;Option&lt;String&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; \n    {\n        let name = if args.is_empty() {\n            &amp;message.author.name\n        } else {\n            args[0]\n        };\n\n        Ok(Some(format!(\"Hello, {}! \ud83d\udc4b Welcome to the server!\", name)))\n    }\n\n    fn description(&amp;self) -&gt; &amp;str {\n        \"Greet someone (or yourself if no name provided)\"\n    }\n}\n\n// Message handler using prefix system\nstruct PrefixHandler {\n    listener: Arc&lt;PrefixListener&gt;,\n}\n\nimpl PrefixHandler {\n    fn new(listener: Arc&lt;PrefixListener&gt;) -&gt; Self {\n        Self { listener }\n    }\n}\n\n#[async_trait]\nimpl MessageHandler for PrefixHandler {\n    async fn on_message_create(\n        &amp;self, \n        message: &amp;ChannelMessage, \n        client: &amp;Client\n    ) -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n        // Skip bot messages\n        if message.author.bot.unwrap_or(false) {\n            return Ok(());\n        }\n\n        // Handle prefix commands\n        if let Some(response) = self.listener.handle_message(message).await? {\n            client.send_text_message(&amp;message.channel_id, &amp;response).await?;\n        }\n\n        Ok(())\n    }\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    dotenv::dotenv().ok();\n    logger::setup_logger(\"info\".to_string())?;\n\n    let token = std::env::var(\"DISCORD_TOKEN\")\n        .expect(\"DISCORD_TOKEN environment variable not set\");\n\n    println!(\"\ud83d\ude80 Starting enhanced Discord bot!\");\n\n    // Create bot\n    let mut bot = BotBase::new(None).await;\n    let user_info = bot.login(token).await;\n    println!(\"\ud83d\udd11 Logged in as: {}\", user_info.username);\n\n    // Set up prefix system\n    let listener = Arc::new(PrefixListener::new(\"!\"));\n\n    // Register commands\n    listener.register_command(\"help\", Box::new(HelpCommand::new(listener.clone()))).await;\n    listener.register_command(\"ping\", Box::new(PingCommand)).await;\n    listener.register_command(\"greet\", Box::new(GreetCommand)).await;\n\n    // Register message handler\n    if let Some(client) = &amp;bot.client {\n        let event_dispatcher = client.get_event_dispatcher();\n        let message_handlers = event_dispatcher.get_message_handlers();\n\n        message_handlers.add_handler(PrefixHandler::new(listener)).await;\n        println!(\"\ud83d\udcdd Prefix handler registered!\");\n    }\n\n    println!(\"\ud83e\udd16 Enhanced bot is running! Available commands:\");\n    println!(\"  \u2022 !help - Show all commands\");\n    println!(\"  \u2022 !ping - Test bot responsiveness\");\n    println!(\"  \u2022 !greet [name] - Greet someone\");\n\n    // Connect and run\n    bot.connect(bot.intents, Some(true)).await;\n\n    loop {\n        tokio::time::sleep(tokio::time::Duration::from_secs(60)).await;\n    }\n}\n</code></pre> <p>Now your bot supports: - <code>!help</code> - Lists all available commands - <code>!ping</code> - Responds with \"Pong! \ud83c\udfd3\" - <code>!greet</code> - Greets you - <code>!greet Alice</code> - Greets Alice</p>"},{"location":"getting-started/first-bot/#common-issues-and-solutions","title":"Common Issues and Solutions","text":""},{"location":"getting-started/first-bot/#bot-token-invalid","title":"Bot Token Invalid","text":"<p><pre><code>Error: HTTP error: 401 Unauthorized\n</code></pre> Solution: Check your bot token in the <code>.env</code> file and ensure it's correct.</p>"},{"location":"getting-started/first-bot/#bot-not-responding","title":"Bot Not Responding","text":"<p><pre><code>Bot connects but doesn't respond to commands\n</code></pre> Solutions: 1. Ensure your bot has \"Send Messages\" permission 2. Check that Message Content Intent is enabled in Discord Developer Portal 3. Verify the bot is invited to the server</p>"},{"location":"getting-started/first-bot/#permission-denied","title":"Permission Denied","text":"<p><pre><code>Error: Missing Access\n</code></pre> Solution: Re-invite your bot with proper permissions using the OAuth2 URL generator.</p>"},{"location":"getting-started/first-bot/#next-steps","title":"Next Steps","text":"<p>Now that you have a working bot:</p> <ol> <li>Add More Commands - Follow the prefix commands guide</li> <li>Add Rich Embeds - Learn about embed messages</li> <li>Handle Events - Explore event handling</li> <li>Deploy Your Bot - Check out deployment options</li> </ol>"},{"location":"getting-started/first-bot/#complete-example-repository","title":"Complete Example Repository","text":"<p>You can find complete working examples in the examples directory of the rustycord repository.</p>"},{"location":"getting-started/first-bot/#getting-help","title":"Getting Help","text":"<ul> <li>Check the troubleshooting guide</li> <li>Browse API documentation</li> <li>Ask questions in GitHub Discussions</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Development Version Warning</p> <p>rustycord is currently in heavy development and is NOT ready for production use.</p> <ul> <li>\ud83d\udea8 Breaking changes occur frequently</li> <li>\ud83d\udea8 APIs are unstable and will change</li> <li>\ud83d\udea8 Features are incomplete</li> <li>\ud83d\udea8 Not suitable for production bots</li> </ul> <p>Only use for learning, experimentation, and development. Do not deploy bots using this library to production environments.</p> <p>Development Status</p> <p>This library is actively being developed. While basic functionality works, many features are missing or incomplete. Check the GitHub repository for the latest status.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing rustycord, make sure you have:</p> <ul> <li>Rust 1.70.0 or later - Install Rust</li> <li>Git - For cloning repositories</li> <li>Discord Bot Token - Create a Discord Application</li> </ul>"},{"location":"getting-started/installation/#installing-rust","title":"Installing Rust","text":"<p>If you don't have Rust installed, you can install it using rustup:</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nsource ~/.cargo/env\n</code></pre> <p>Verify your installation:</p> <pre><code>rustc --version\ncargo --version\n</code></pre>"},{"location":"getting-started/installation/#creating-a-new-project","title":"Creating a New Project","text":"<p>Create a new Rust project for your Discord bot:</p> <pre><code>cargo new my-discord-bot\ncd my-discord-bot\n</code></pre>"},{"location":"getting-started/installation/#adding-rustycord-dependency","title":"Adding rustycord Dependency","text":"<p>Add rustycord and required dependencies to your <code>Cargo.toml</code>:</p> <pre><code>[package]\nname = \"my-discord-bot\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\nrustycord = \"0.1.0\"\ntokio = { version = \"1.40\", features = [\"full\"] }\nasync-trait = \"0.1\"\nlog = \"0.4\"\n</code></pre>"},{"location":"getting-started/installation/#setting-up-your-discord-bot","title":"Setting Up Your Discord Bot","text":""},{"location":"getting-started/installation/#1-create-a-discord-application","title":"1. Create a Discord Application","text":"<ol> <li>Go to the Discord Developer Portal</li> <li>Click \"New Application\"</li> <li>Give your application a name</li> <li>Navigate to the \"Bot\" section</li> <li>Click \"Add Bot\"</li> <li>Copy your bot token (keep this secret!)</li> </ol>"},{"location":"getting-started/installation/#2-configure-bot-permissions","title":"2. Configure Bot Permissions","text":"<p>In the \"Bot\" section of your application:</p> <ol> <li>Enable the following Privileged Gateway Intents:</li> <li>Message Content Intent (if you need to read message content)</li> <li>Server Members Intent (if you need member information)</li> <li> <p>Presence Intent (if you need presence information)</p> </li> <li> <p>In the \"OAuth2\" &gt; \"URL Generator\" section:</p> </li> <li>Select \"bot\" scope</li> <li> <p>Select required permissions:</p> <ul> <li>Send Messages</li> <li>Read Message History</li> <li>Use Slash Commands (if needed)</li> </ul> </li> <li> <p>Use the generated URL to invite your bot to a server</p> </li> </ol>"},{"location":"getting-started/installation/#3-set-up-environment-variables","title":"3. Set Up Environment Variables","text":"<p>Create a <code>.env</code> file in your project root:</p> <pre><code>DISCORD_TOKEN=your_bot_token_here\n</code></pre> <p>Add <code>.env</code> to your <code>.gitignore</code>:</p> <pre><code>.env\ntarget/\nCargo.lock\n</code></pre>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>Create a simple test bot in <code>src/main.rs</code>:</p> <pre><code>use rustycord::{Bot, Client, logger};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Load environment variables\n    dotenv::dotenv().ok();\n\n    // Initialize logging\n    logger::setup_logger(logger::LogLevel::Info)?;\n\n    // Get bot token\n    let token = std::env::var(\"DISCORD_TOKEN\")\n        .expect(\"DISCORD_TOKEN environment variable not set\");\n\n    // Create client and bot\n    println!(\"Creating Discord client...\");\n    let client = Client::new(&amp;token).await?;\n\n    println!(\"Starting bot...\");\n    let bot = Bot::new(client);\n    bot.start().await?;\n\n    Ok(())\n}\n</code></pre> <p>Add the <code>dotenv</code> dependency to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\n# ... existing dependencies\ndotenv = \"0.15\"\n</code></pre> <p>Run your bot:</p> <pre><code>cargo run\n</code></pre> <p>You should see log output indicating your bot has connected to Discord!</p>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<p>Now that you have rustycord installed and a basic bot running:</p> <ul> <li>Create Your First Bot - Build a simple echo bot</li> <li>Bot Configuration - Learn about bot settings</li> <li>Message Handlers - Handle user messages</li> </ul>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#common-issues","title":"Common Issues","text":"<p>Bot token is invalid: <pre><code>Error: HTTP error: 401 Unauthorized\n</code></pre> - Verify your bot token is correct - Make sure there are no extra spaces in your <code>.env</code> file</p> <p>Permission denied: <pre><code>Error: Missing Access\n</code></pre> - Check that your bot has the required permissions in the Discord server - Verify the bot is properly invited to the server</p> <p>Connection timeout: <pre><code>Error: Connection timeout\n</code></pre> - Check your internet connection - Verify Discord's status at discordstatus.com</p>"},{"location":"getting-started/installation/#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Check the troubleshooting guide</li> <li>Search GitHub Issues</li> <li>Create a new issue with:</li> <li>Your Rust version (<code>rustc --version</code>)</li> <li>Your operating system</li> <li>Complete error messages</li> <li>Minimal reproduction code</li> </ol>"},{"location":"user-guide/bot-basics/","title":"Bot Basics","text":"<p>Learn the fundamental concepts and patterns for building Discord bots with rustycord.</p>"},{"location":"user-guide/bot-basics/#overview","title":"Overview","text":"<p>This guide covers the essential concepts you need to understand when building Discord bots with rustycord, including bot lifecycle, event handling, permissions, and best practices.</p>"},{"location":"user-guide/bot-basics/#bot-architecture","title":"Bot Architecture","text":"<pre><code>use rustycord::{Bot, Client, MessageHandler, logger};\nuse rustycord::models::{Message, User};\nuse rustycord::gateway::intents::Intents;\nuse async_trait::async_trait;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Setup logging\n    logger::setup_logger(\"info\".to_string())?;\n\n    // Create bot with specific intents\n    let intents = Intents::GUILD_MESSAGES | Intents::MESSAGE_CONTENT;\n    let mut bot = Bot::new(Some(intents.bits() as i32)).await;\n\n    // Login\n    let token = std::env::var(\"DISCORD_TOKEN\")?;\n    bot.login(token).await;\n\n    // Register handlers\n    bot.register_message_handler(Box::new(BasicCommandHandler));\n    bot.register_message_handler(Box::new(AdminHandler::new()));\n\n    // Start the bot\n    bot.start().await?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"user-guide/bot-basics/#bot-lifecycle","title":"Bot Lifecycle","text":""},{"location":"user-guide/bot-basics/#1-initialization","title":"1. Initialization","text":"<pre><code>// Create bot instance\nlet mut bot = Bot::new(None).await;\n\n// Configure bot settings\nbot.set_activity(\"Watching for commands\");\nbot.set_status(\"online\");\n</code></pre>"},{"location":"user-guide/bot-basics/#2-authentication","title":"2. Authentication","text":"<pre><code>// Login with bot token\nlet user_response = bot.login(token).await;\nlog::info!(\"Bot logged in as: {}\", user_response.username);\n</code></pre>"},{"location":"user-guide/bot-basics/#3-handler-registration","title":"3. Handler Registration","text":"<pre><code>// Register message handlers\nbot.register_message_handler(Box::new(CommandHandler));\nbot.register_message_handler(Box::new(ModerationHandler));\n\n// Register event handlers (future feature)\n// bot.register_event_handler(Box::new(GuildHandler));\n</code></pre>"},{"location":"user-guide/bot-basics/#4-event-loop","title":"4. Event Loop","text":"<pre><code>// Start the bot (blocking call)\nbot.start().await?;\n</code></pre>"},{"location":"user-guide/bot-basics/#message-handling-patterns","title":"Message Handling Patterns","text":""},{"location":"user-guide/bot-basics/#basic-command-handler","title":"Basic Command Handler","text":"<pre><code>struct BasicCommandHandler;\n\n#[async_trait]\nimpl MessageHandler for BasicCommandHandler {\n    async fn handle_message(&amp;self, message: &amp;Message) -&gt; Result&lt;Option&lt;String&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n        // Ignore bot messages\n        if message.author.bot.unwrap_or(false) {\n            return Ok(None);\n        }\n\n        // Parse command\n        let content = message.content.trim();\n        if !content.starts_with('!') {\n            return Ok(None);\n        }\n\n        let parts: Vec&lt;&amp;str&gt; = content[1..].split_whitespace().collect();\n        if parts.is_empty() {\n            return Ok(None);\n        }\n\n        let command = parts[0].to_lowercase();\n        let args = &amp;parts[1..];\n\n        match command.as_str() {\n            \"ping\" =&gt; Ok(Some(\"\ud83c\udfd3 Pong!\".to_string())),\n            \"help\" =&gt; Ok(Some(self.get_help_text())),\n            \"echo\" =&gt; {\n                if args.is_empty() {\n                    Ok(Some(\"\u274c Please provide text to echo.\".to_string()))\n                } else {\n                    Ok(Some(args.join(\" \")))\n                }\n            },\n            \"info\" =&gt; Ok(Some(self.get_bot_info())),\n            _ =&gt; Ok(None), // Command not handled by this handler\n        }\n    }\n}\n\nimpl BasicCommandHandler {\n    fn get_help_text(&amp;self) -&gt; String {\n        \"\ud83d\udcda **Available Commands**\\n\\\n         `!ping` - Test bot responsiveness\\n\\\n         `!help` - Show this help message\\n\\\n         `!echo &lt;text&gt;` - Echo your message\\n\\\n         `!info` - Show bot information\".to_string()\n    }\n\n    fn get_bot_info(&amp;self) -&gt; String {\n        \"\ud83e\udd16 **Bot Information**\\n\\\n         Name: RustyCord Bot\\n\\\n         Version: 0.1.1\\n\\\n         Language: Rust\\n\\\n         Library: RustyCord\".to_string()\n    }\n}\n</code></pre>"},{"location":"user-guide/bot-basics/#advanced-command-handler-with-subcommands","title":"Advanced Command Handler with Subcommands","text":"<pre><code>use std::collections::HashMap;\n\nstruct AdvancedCommandHandler {\n    commands: HashMap&lt;String, Box&lt;dyn Command + Send + Sync&gt;&gt;,\n}\n\n#[async_trait]\ntrait Command {\n    async fn execute(&amp;self, args: &amp;[&amp;str], message: &amp;Message) -&gt; Result&lt;String, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt;;\n    fn description(&amp;self) -&gt; &amp;str;\n    fn usage(&amp;self) -&gt; &amp;str;\n}\n\nimpl AdvancedCommandHandler {\n    fn new() -&gt; Self {\n        let mut commands: HashMap&lt;String, Box&lt;dyn Command + Send + Sync&gt;&gt; = HashMap::new();\n\n        commands.insert(\"user\".to_string(), Box::new(UserCommand));\n        commands.insert(\"server\".to_string(), Box::new(ServerCommand));\n        commands.insert(\"math\".to_string(), Box::new(MathCommand));\n\n        Self { commands }\n    }\n}\n\n#[async_trait]\nimpl MessageHandler for AdvancedCommandHandler {\n    async fn handle_message(&amp;self, message: &amp;Message) -&gt; Result&lt;Option&lt;String&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n        if !message.content.starts_with('!') {\n            return Ok(None);\n        }\n\n        let parts: Vec&lt;&amp;str&gt; = message.content[1..].split_whitespace().collect();\n        if parts.is_empty() {\n            return Ok(None);\n        }\n\n        let command_name = parts[0].to_lowercase();\n        let args = &amp;parts[1..];\n\n        if let Some(command) = self.commands.get(&amp;command_name) {\n            match command.execute(args, message).await {\n                Ok(response) =&gt; Ok(Some(response)),\n                Err(e) =&gt; Ok(Some(format!(\"\u274c Error executing command: {}\", e))),\n            }\n        } else if command_name == \"help\" {\n            Ok(Some(self.generate_help()))\n        } else {\n            Ok(None)\n        }\n    }\n}\n\nimpl AdvancedCommandHandler {\n    fn generate_help(&amp;self) -&gt; String {\n        let mut help = \"\ud83d\udcda **Available Commands**\\n\".to_string();\n\n        for (name, command) in &amp;self.commands {\n            help.push_str(&amp;format!(\n                \"`!{} {}` - {}\\n\",\n                name,\n                command.usage(),\n                command.description()\n            ));\n        }\n\n        help.push_str(\"`!help` - Show this help message\");\n        help\n    }\n}\n\n// Command implementations\nstruct UserCommand;\n\n#[async_trait]\nimpl Command for UserCommand {\n    async fn execute(&amp;self, args: &amp;[&amp;str], message: &amp;Message) -&gt; Result&lt;String, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n        match args.get(0) {\n            Some(&amp;\"info\") =&gt; {\n                Ok(format!(\n                    \"\ud83d\udc64 **User Information**\\n\\\n                     Username: {}\\n\\\n                     User ID: {}\\n\\\n                     Account Type: {}\",\n                    message.author.username,\n                    message.author.id,\n                    if message.author.bot.unwrap_or(false) { \"Bot\" } else { \"User\" }\n                ))\n            },\n            Some(&amp;\"avatar\") =&gt; {\n                Ok(format!(\n                    \"\ud83d\uddbc\ufe0f **User Avatar**\\n\\\n                     Username: {}\\n\\\n                     Avatar URL: {}\",\n                    message.author.username,\n                    message.author.avatar_url().unwrap_or(\"No avatar\".to_string())\n                ))\n            },\n            _ =&gt; Ok(\"\u2753 Available subcommands: `info`, `avatar`\".to_string()),\n        }\n    }\n\n    fn description(&amp;self) -&gt; &amp;str {\n        \"User-related commands\"\n    }\n\n    fn usage(&amp;self) -&gt; &amp;str {\n        \"&lt;info|avatar&gt;\"\n    }\n}\n\nstruct ServerCommand;\n\n#[async_trait]\nimpl Command for ServerCommand {\n    async fn execute(&amp;self, args: &amp;[&amp;str], message: &amp;Message) -&gt; Result&lt;String, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n        match args.get(0) {\n            Some(&amp;\"info\") =&gt; {\n                Ok(format!(\n                    \"\ud83c\udfe0 **Server Information**\\n\\\n                     Guild ID: {}\\n\\\n                     Channel ID: {}\",\n                    message.guild_id.unwrap_or_default(),\n                    message.channel_id\n                ))\n            },\n            _ =&gt; Ok(\"\u2753 Available subcommands: `info`\".to_string()),\n        }\n    }\n\n    fn description(&amp;self) -&gt; &amp;str {\n        \"Server-related commands\"\n    }\n\n    fn usage(&amp;self) -&gt; &amp;str {\n        \"&lt;info&gt;\"\n    }\n}\n\nstruct MathCommand;\n\n#[async_trait]\nimpl Command for MathCommand {\n    async fn execute(&amp;self, args: &amp;[&amp;str], message: &amp;Message) -&gt; Result&lt;String, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n        if args.len() != 3 {\n            return Ok(\"\u2753 Usage: `!math &lt;number&gt; &lt;operator&gt; &lt;number&gt;`\".to_string());\n        }\n\n        let a: f64 = args[0].parse().map_err(|_| \"Invalid first number\")?;\n        let op = args[1];\n        let b: f64 = args[2].parse().map_err(|_| \"Invalid second number\")?;\n\n        let result = match op {\n            \"+\" =&gt; a + b,\n            \"-\" =&gt; a - b,\n            \"*\" =&gt; a * b,\n            \"/\" =&gt; {\n                if b == 0.0 {\n                    return Ok(\"\u274c Division by zero\".to_string());\n                }\n                a / b\n            },\n            \"%\" =&gt; a % b,\n            \"^\" =&gt; a.powf(b),\n            _ =&gt; return Ok(\"\u274c Supported operators: +, -, *, /, %, ^\".to_string()),\n        };\n\n        Ok(format!(\"\ud83e\uddee {} {} {} = {}\", a, op, b, result))\n    }\n\n    fn description(&amp;self) -&gt; &amp;str {\n        \"Basic math operations\"\n    }\n\n    fn usage(&amp;self) -&gt; &amp;str {\n        \"&lt;number&gt; &lt;operator&gt; &lt;number&gt;\"\n    }\n}\n</code></pre>"},{"location":"user-guide/bot-basics/#permission-handling","title":"Permission Handling","text":"<pre><code>use rustycord::models::{User, Role, Permission};\n\nstruct PermissionChecker;\n\nimpl PermissionChecker {\n    fn has_permission(user: &amp;User, required_permission: Permission) -&gt; bool {\n        // In a real implementation, you'd check Discord permissions\n        // This is a simplified example\n        user.roles.iter().any(|role| role.permissions.contains(required_permission))\n    }\n\n    fn is_admin(user: &amp;User) -&gt; bool {\n        Self::has_permission(user, Permission::ADMINISTRATOR)\n    }\n\n    fn is_moderator(user: &amp;User) -&gt; bool {\n        Self::has_permission(user, Permission::MANAGE_MESSAGES) ||\n        Self::has_permission(user, Permission::KICK_MEMBERS) ||\n        Self::is_admin(user)\n    }\n\n    fn can_manage_roles(user: &amp;User) -&gt; bool {\n        Self::has_permission(user, Permission::MANAGE_ROLES) || Self::is_admin(user)\n    }\n}\n\n// Usage in command handler\nstruct AdminHandler;\n\n#[async_trait]\nimpl MessageHandler for AdminHandler {\n    async fn handle_message(&amp;self, message: &amp;Message) -&gt; Result&lt;Option&lt;String&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n        if !message.content.starts_with(\"!admin \") {\n            return Ok(None);\n        }\n\n        // Check if user has admin permissions\n        if !PermissionChecker::is_admin(&amp;message.author) {\n            return Ok(Some(\"\u274c You don't have permission to use admin commands.\".to_string()));\n        }\n\n        let command = message.content.strip_prefix(\"!admin \").unwrap_or(\"\");\n\n        match command {\n            \"shutdown\" =&gt; {\n                log::warn!(\"\ud83d\uded1 Admin {} requested bot shutdown\", message.author.username);\n                Ok(Some(\"\ud83d\uded1 Shutting down bot...\".to_string()))\n            },\n            \"restart\" =&gt; {\n                log::info!(\"\ud83d\udd04 Admin {} requested bot restart\", message.author.username);\n                Ok(Some(\"\ud83d\udd04 Restarting bot...\".to_string()))\n            },\n            \"stats\" =&gt; {\n                Ok(Some(self.get_bot_stats()))\n            },\n            _ =&gt; Ok(Some(\"\u2753 Available admin commands: shutdown, restart, stats\".to_string())),\n        }\n    }\n}\n\nimpl AdminHandler {\n    fn get_bot_stats(&amp;self) -&gt; String {\n        \"\ud83d\udcca **Bot Statistics**\\n\\\n         Uptime: 2 hours, 34 minutes\\n\\\n         Messages Processed: 1,247\\n\\\n         Commands Executed: 89\\n\\\n         Memory Usage: 45.2 MB\\n\\\n         Active Connections: 1\".to_string()\n    }\n}\n</code></pre>"},{"location":"user-guide/bot-basics/#error-handling","title":"Error Handling","text":"<pre><code>use anyhow::{Context, Result};\n\n#[async_trait]\nimpl MessageHandler for ErrorHandlingHandler {\n    async fn handle_message(&amp;self, message: &amp;Message) -&gt; Result&lt;Option&lt;String&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n        if !message.content.starts_with(\"!test\") {\n            return Ok(None);\n        }\n\n        match self.process_test_command(message).await {\n            Ok(response) =&gt; Ok(Some(response)),\n            Err(e) =&gt; {\n                log::error!(\"\u274c Error processing test command: {:#}\", e);\n                Ok(Some(\"\u274c An error occurred while processing your command.\".to_string()))\n            }\n        }\n    }\n}\n\nimpl ErrorHandlingHandler {\n    async fn process_test_command(&amp;self, message: &amp;Message) -&gt; Result&lt;String&gt; {\n        // Simulate potential failure points\n        self.validate_user(message)\n            .context(\"User validation failed\")?;\n\n        let data = self.fetch_data()\n            .await\n            .context(\"Failed to fetch required data\")?;\n\n        let processed = self.process_data(data)\n            .context(\"Data processing failed\")?;\n\n        Ok(format!(\"\u2705 Command completed: {}\", processed))\n    }\n\n    fn validate_user(&amp;self, message: &amp;Message) -&gt; Result&lt;()&gt; {\n        if message.author.username.is_empty() {\n            anyhow::bail!(\"Username cannot be empty\");\n        }\n        Ok(())\n    }\n\n    async fn fetch_data(&amp;self) -&gt; Result&lt;String&gt; {\n        // Simulate async operation that might fail\n        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;\n        Ok(\"sample_data\".to_string())\n    }\n\n    fn process_data(&amp;self, data: String) -&gt; Result&lt;String&gt; {\n        if data.is_empty() {\n            anyhow::bail!(\"Cannot process empty data\");\n        }\n        Ok(format!(\"processed_{}\", data))\n    }\n}\n</code></pre>"},{"location":"user-guide/bot-basics/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/bot-basics/#1-handler-organization","title":"1. Handler Organization","text":"<pre><code>// Organize handlers by functionality\nmod handlers {\n    pub mod commands;\n    pub mod moderation;\n    pub mod utility;\n    pub mod fun;\n}\n\n// Register handlers in a organized way\nfn register_handlers(bot: &amp;mut Bot) {\n    // Core functionality\n    bot.register_message_handler(Box::new(handlers::commands::BasicCommands));\n    bot.register_message_handler(Box::new(handlers::utility::UtilityCommands));\n\n    // Moderation (order matters - check permissions first)\n    bot.register_message_handler(Box::new(handlers::moderation::ModerationCommands));\n\n    // Fun commands (last, as they might be catch-all)\n    bot.register_message_handler(Box::new(handlers::fun::FunCommands));\n}\n</code></pre>"},{"location":"user-guide/bot-basics/#2-configuration-management","title":"2. Configuration Management","text":"<pre><code>use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Deserialize, Serialize)]\nstruct BotConfig {\n    pub token: String,\n    pub prefix: String,\n    pub log_level: String,\n    pub owner_id: String,\n    pub admin_roles: Vec&lt;String&gt;,\n    pub disabled_commands: Vec&lt;String&gt;,\n}\n\nimpl BotConfig {\n    fn load() -&gt; Result&lt;Self, Box&lt;dyn std::error::Error&gt;&gt; {\n        let config_str = std::fs::read_to_string(\"config.toml\")?;\n        let config: BotConfig = toml::from_str(&amp;config_str)?;\n        Ok(config)\n    }\n}\n</code></pre>"},{"location":"user-guide/bot-basics/#3-rate-limiting","title":"3. Rate Limiting","text":"<pre><code>use std::collections::HashMap;\nuse std::time::{Duration, Instant};\nuse std::sync::{Arc, Mutex};\n\n#[derive(Debug)]\nstruct RateLimiter {\n    user_last_command: Arc&lt;Mutex&lt;HashMap&lt;String, Instant&gt;&gt;&gt;,\n    cooldown: Duration,\n}\n\nimpl RateLimiter {\n    fn new(cooldown_seconds: u64) -&gt; Self {\n        Self {\n            user_last_command: Arc::new(Mutex::new(HashMap::new())),\n            cooldown: Duration::from_secs(cooldown_seconds),\n        }\n    }\n\n    fn check_rate_limit(&amp;self, user_id: &amp;str) -&gt; bool {\n        let mut last_commands = self.user_last_command.lock().unwrap();\n        let now = Instant::now();\n\n        if let Some(last_time) = last_commands.get(user_id) {\n            if now.duration_since(*last_time) &lt; self.cooldown {\n                return false; // Rate limited\n            }\n        }\n\n        last_commands.insert(user_id.to_string(), now);\n        true // Allow command\n    }\n}\n</code></pre>"},{"location":"user-guide/bot-basics/#testing","title":"Testing","text":"<pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n    use rustycord::models::{User, Message};\n\n    fn create_test_message(content: &amp;str, username: &amp;str) -&gt; Message {\n        Message {\n            content: content.to_string(),\n            author: User {\n                id: \"123456789\".to_string(),\n                username: username.to_string(),\n                bot: Some(false),\n                // ... other fields\n            },\n            // ... other fields\n        }\n    }\n\n    #[tokio::test]\n    async fn test_basic_command_handler() {\n        let handler = BasicCommandHandler;\n        let message = create_test_message(\"!ping\", \"testuser\");\n\n        let result = handler.handle_message(&amp;message).await.unwrap();\n        assert_eq!(result, Some(\"\ud83c\udfd3 Pong!\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn test_echo_command() {\n        let handler = BasicCommandHandler;\n        let message = create_test_message(\"!echo Hello World\", \"testuser\");\n\n        let result = handler.handle_message(&amp;message).await.unwrap();\n        assert_eq!(result, Some(\"Hello World\".to_string()));\n    }\n\n    #[tokio::test]\n    async fn test_non_command_message() {\n        let handler = BasicCommandHandler;\n        let message = create_test_message(\"Hello there\", \"testuser\");\n\n        let result = handler.handle_message(&amp;message).await.unwrap();\n        assert_eq!(result, None);\n    }\n}\n</code></pre>"},{"location":"user-guide/bot-basics/#related-documentation","title":"Related Documentation","text":"<ul> <li>Installation Guide - Set up your development environment</li> <li>Prefix Commands - Advanced command patterns</li> <li>Examples - Working code examples</li> </ul>"},{"location":"user-guide/prefix-commands/","title":"Prefix Commands","text":"<p>rustycord provides a powerful prefix-based command system that allows you to easily create and manage bot commands with specific prefixes (like <code>!</code>, <code>?</code>, or custom prefixes).</p>"},{"location":"user-guide/prefix-commands/#overview","title":"Overview","text":"<p>The prefix command system consists of:</p> <ul> <li><code>PrefixListener</code> - Manages commands for a specific prefix</li> <li><code>PrefixCommand</code> trait - Define your own commands</li> <li>Built-in commands (<code>HelpCommand</code>, <code>PingCommand</code>, <code>EchoPrefixCommand</code>)</li> <li>Integration with the existing message handler system</li> </ul>"},{"location":"user-guide/prefix-commands/#basic-usage","title":"Basic Usage","text":""},{"location":"user-guide/prefix-commands/#1-create-a-prefix-listener","title":"1. Create a Prefix Listener","text":"<pre><code>use rustycord::prefix::PrefixListener;\nuse std::sync::Arc;\n\n// Create a listener for \"!\" prefix\nlet listener = Arc::new(PrefixListener::new(\"!\"));\n\n// For case-sensitive commands\nlet case_listener = Arc::new(PrefixListener::new_case_sensitive(\"!\"));\n</code></pre>"},{"location":"user-guide/prefix-commands/#2-register-built-in-commands","title":"2. Register Built-in Commands","text":"<pre><code>use rustycord::prefix::{HelpCommand, PingCommand, EchoPrefixCommand};\n\n// Register built-in commands\nlistener.register_command(\"help\", Box::new(HelpCommand::new(listener.clone()))).await;\nlistener.register_command(\"ping\", Box::new(PingCommand)).await;\nlistener.register_command(\"echo\", Box::new(EchoPrefixCommand)).await;\n</code></pre>"},{"location":"user-guide/prefix-commands/#3-create-custom-commands","title":"3. Create Custom Commands","text":"<pre><code>use async_trait::async_trait;\nuse rustycord::prefix::PrefixCommand;\nuse rustycord::message::ChannelMessage;\n\nstruct InfoCommand;\n\n#[async_trait]\nimpl PrefixCommand for InfoCommand {\n    async fn execute(&amp;self, message: &amp;ChannelMessage, _args: Vec&lt;&amp;str&gt;) \n        -&gt; Result&lt;Option&lt;String&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; \n    {\n        let response = format!(\n            \"**Server Information**\\\\n\\\\\n             Channel ID: {}\\\\n\\\\\n             Your ID: {}\",\n            message.channel_id,\n            message.author.id\n        );\n        Ok(Some(response))\n    }\n\n    fn description(&amp;self) -&gt; &amp;str {\n        \"Show information about the current server and channel\"\n    }\n\n    fn aliases(&amp;self) -&gt; Vec&lt;&amp;str&gt; {\n        vec![\"server\", \"guild\"]\n    }\n}\n\n// Register the custom command\nlistener.register_command(\"info\", Box::new(InfoCommand)).await;\n</code></pre>"},{"location":"user-guide/prefix-commands/#4-integrate-with-message-handler","title":"4. Integrate with Message Handler","text":"<pre><code>use rustycord::handlers::message_handler::MessageHandler;\n\nstruct PrefixMessageHandler {\n    listener: Arc&lt;PrefixListener&gt;,\n}\n\nimpl PrefixMessageHandler {\n    fn new(listener: Arc&lt;PrefixListener&gt;) -&gt; Self {\n        Self { listener }\n    }\n}\n\n#[async_trait]\nimpl MessageHandler for PrefixMessageHandler {\n    async fn on_message_create(&amp;self, message: &amp;ChannelMessage, client: &amp;Client) \n        -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; \n    {\n        // Skip messages from bots\n        if message.author.bot.unwrap_or(false) {\n            return Ok(());\n        }\n\n        // Try to handle the message with the prefix listener\n        if let Some(response) = self.listener.handle_message(message).await? {\n            client.send_text_message(&amp;message.channel_id, &amp;response).await?;\n        }\n\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"user-guide/prefix-commands/#5-register-with-event-dispatcher","title":"5. Register with Event Dispatcher","text":"<pre><code>// Register with the bot's event dispatcher\nif let Some(client) = &amp;bot.client {\n    let event_dispatcher = client.get_event_dispatcher();\n    let message_handlers = event_dispatcher.get_message_handlers();\n\n    message_handlers.add_handler(PrefixMessageHandler::new(listener.clone())).await;\n}\n</code></pre>"},{"location":"user-guide/prefix-commands/#built-in-commands","title":"Built-in Commands","text":""},{"location":"user-guide/prefix-commands/#help-command","title":"Help Command","text":"<p>The <code>HelpCommand</code> automatically lists all registered commands and provides detailed help.</p> <pre><code>// Usage in Discord:\n// !help          - Lists all commands\n// !help &lt;command&gt; - Shows help for specific command\n</code></pre>"},{"location":"user-guide/prefix-commands/#ping-command","title":"Ping Command","text":"<p>A simple responsiveness test command.</p> <pre><code>// Usage: !ping\n// Response: \"Pong! \ud83c\udfd3\"\n</code></pre>"},{"location":"user-guide/prefix-commands/#echo-command","title":"Echo Command","text":"<p>Echoes back the provided text.</p> <pre><code>// Usage: !echo Hello World\n// Response: \"Hello World\"\n</code></pre>"},{"location":"user-guide/prefix-commands/#advanced-examples","title":"Advanced Examples","text":""},{"location":"user-guide/prefix-commands/#math-calculator-command","title":"Math Calculator Command","text":"<pre><code>struct MathCommand;\n\n#[async_trait]\nimpl PrefixCommand for MathCommand {\n    async fn execute(&amp;self, _message: &amp;ChannelMessage, args: Vec&lt;&amp;str&gt;) \n        -&gt; Result&lt;Option&lt;String&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; \n    {\n        if args.len() &lt; 3 {\n            return Ok(Some(\"Usage: `!math &lt;number&gt; &lt;operator&gt; &lt;number&gt;`\\\\nExample: `!math 5 + 3`\".to_string()));\n        }\n\n        let num1: f64 = match args[0].parse() {\n            Ok(n) =&gt; n,\n            Err(_) =&gt; return Ok(Some(\"Invalid first number\".to_string())),\n        };\n\n        let operator = args[1];\n\n        let num2: f64 = match args[2].parse() {\n            Ok(n) =&gt; n,\n            Err(_) =&gt; return Ok(Some(\"Invalid second number\".to_string())),\n        };\n\n        let result = match operator {\n            \"+\" =&gt; num1 + num2,\n            \"-\" =&gt; num1 - num2,\n            \"*\" | \"x\" =&gt; num1 * num2,\n            \"/\" =&gt; {\n                if num2 == 0.0 {\n                    return Ok(Some(\"Cannot divide by zero!\".to_string()));\n                }\n                num1 / num2\n            }\n            \"%\" =&gt; num1 % num2,\n            \"^\" | \"**\" =&gt; num1.powf(num2),\n            _ =&gt; return Ok(Some(\"Unknown operator. Supported: +, -, *, /, %, ^\".to_string())),\n        };\n\n        Ok(Some(format!(\"{} {} {} = {}\", num1, operator, num2, result)))\n    }\n\n    fn description(&amp;self) -&gt; &amp;str {\n        \"Perform basic math calculations\"\n    }\n\n    fn aliases(&amp;self) -&gt; Vec&lt;&amp;str&gt; {\n        vec![\"calc\", \"calculate\"]\n    }\n}\n</code></pre>"},{"location":"user-guide/prefix-commands/#user-information-command","title":"User Information Command","text":"<pre><code>struct UserCommand;\n\n#[async_trait]\nimpl PrefixCommand for UserCommand {\n    async fn execute(&amp;self, message: &amp;ChannelMessage, _args: Vec&lt;&amp;str&gt;) \n        -&gt; Result&lt;Option&lt;String&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; \n    {\n        let user = &amp;message.author;\n\n        let response = format!(\n            \"**User Information**\\\\n\\\\\n             Username: {}#{}\\\\n\\\\\n             ID: {}\\\\n\\\\\n             Bot: {}\\\\n\\\\\n             MFA Enabled: {}\",\n            user.name,\n            user.discriminator,\n            user.id,\n            user.bot.unwrap_or(false),\n            user.mfa_enabled\n        );\n\n        Ok(Some(response))\n    }\n\n    fn description(&amp;self) -&gt; &amp;str {\n        \"Show information about a user (defaults to yourself)\"\n    }\n\n    fn aliases(&amp;self) -&gt; Vec&lt;&amp;str&gt; {\n        vec![\"whois\", \"profile\"]\n    }\n}\n</code></pre>"},{"location":"user-guide/prefix-commands/#complete-example","title":"Complete Example","text":"<p>See the prefix commands example for a complete working bot that demonstrates all these features.</p>"},{"location":"user-guide/prefix-commands/#api-reference","title":"API Reference","text":""},{"location":"user-guide/prefix-commands/#prefixlistener","title":"PrefixListener","text":"<ul> <li><code>new(prefix: &amp;str)</code> - Create a new case-insensitive prefix listener</li> <li><code>new_case_sensitive(prefix: &amp;str)</code> - Create a case-sensitive prefix listener</li> <li><code>register_command(name: &amp;str, command: Box&lt;dyn PrefixCommand&gt;)</code> - Register a command</li> <li><code>unregister_command(name: &amp;str)</code> - Remove a command</li> <li><code>handle_message(message: &amp;ChannelMessage)</code> - Process a message for commands</li> <li><code>list_commands()</code> - Get all registered command names</li> <li><code>get_command_help(command_name: &amp;str)</code> - Get help for a specific command</li> <li><code>prefix()</code> - Get the prefix being used</li> </ul>"},{"location":"user-guide/prefix-commands/#prefixcommand-trait","title":"PrefixCommand Trait","text":"<ul> <li><code>execute(message: &amp;ChannelMessage, args: Vec&lt;&amp;str&gt;)</code> - Execute the command</li> <li><code>description()</code> - Get command description for help</li> <li><code>aliases()</code> - Get command aliases (optional)</li> </ul>"},{"location":"user-guide/prefix-commands/#best-practices","title":"Best Practices","text":"<ol> <li>Use descriptive command names - Make commands easy to discover</li> <li>Provide good help text - Users should understand what commands do</li> <li>Handle errors gracefully - Return helpful error messages</li> <li>Use aliases for common commands - Make frequently used commands easy to type</li> <li>Skip bot messages - Always check <code>message.author.bot</code> to avoid infinite loops</li> <li>Validate arguments - Check argument count and types before processing</li> <li>Use case-insensitive commands - Unless you specifically need case sensitivity</li> </ol>"},{"location":"user-guide/prefix-commands/#error-handling","title":"Error Handling","text":"<p>Commands should return <code>Result&lt;Option&lt;String&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt;</code>:</p> <ul> <li><code>Ok(Some(response))</code> - Command executed successfully with a response</li> <li><code>Ok(None)</code> - Command executed successfully but no response needed</li> <li><code>Err(error)</code> - Command failed with an error</li> </ul> <p>The prefix system will log errors and continue processing other messages.</p>"},{"location":"user-guide/prefix-commands/#limitations","title":"Limitations","text":"<ul> <li>Commands are processed sequentially, not in parallel</li> <li>Aliases are logged but not currently stored (feature limitation)</li> <li>No built-in cooldown or rate limiting (implement in your command)</li> <li>No built-in permission system (implement in your command)</li> </ul>"},{"location":"user-guide/prefix-commands/#migration-from-simple-message-handlers","title":"Migration from Simple Message Handlers","text":"<p>If you're currently using simple message handlers with manual prefix checking:</p> <pre><code>// Old approach\nif message.content.starts_with(\"!ping\") {\n    client.send_text_message(&amp;message.channel_id, \"Pong!\").await?;\n}\n\n// New approach with prefix system\nstruct PingCommand;\n\n#[async_trait]\nimpl PrefixCommand for PingCommand {\n    async fn execute(&amp;self, _message: &amp;ChannelMessage, _args: Vec&lt;&amp;str&gt;) \n        -&gt; Result&lt;Option&lt;String&gt;, Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; \n    {\n        Ok(Some(\"Pong!\".to_string()))\n    }\n\n    fn description(&amp;self) -&gt; &amp;str {\n        \"Test if the bot is responding\"\n    }\n}\n</code></pre> <p>The prefix system provides better organization, automatic help generation, and easier command management.</p>"}]}